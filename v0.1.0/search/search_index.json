{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"GEAS-AI Documentation","text":"<p>Welcome to the official documentation for GEAS-AI (Governance Enforcement for Agentic Systems).</p>"},{"location":"#quick-links","title":"\ud83c\udfc1 Quick Links","text":"<ul> <li>Getting Started: Your guide to installing and running your first GEAS Bolt.</li> <li>About: Learn more about GEAS-AI.</li> <li>API Reference: Learn how to use GEAS-AI in your projects.</li> </ul>"},{"location":"#commands","title":"\ud83d\udee0 Commands","text":"<ul> <li><code>geas init</code> - Initialize GEAS in a project.</li> <li><code>geas new &lt;name&gt;</code> - Create a new unit of work (Bolt).</li> <li><code>geas seal &lt;target&gt;</code> - Seal a blueprint artifact.</li> <li><code>geas verify</code> - Verify the integrity of the active Bolt.</li> <li><code>geas status</code> - Show the current governance status.</li> </ul>"},{"location":"WHITE_PAPER/","title":"GEAS-AI Whitepaper","text":"<p>Protocol for Agent Control &amp; Trust</p>"},{"location":"WHITE_PAPER/#executive-summary","title":"Executive Summary","text":"<p>GEAS-AI is a repository-native governance protocol designed for Software Engineering 3.0 (SE 3.0). As development shifts from human-authored code to AI-generated implementation, the critical bottleneck moves from \"Writing Speed\" to \"Trust &amp; Verification.\"</p> <p>GEAS goal is to implement a strict AI-DLC (AI Development Life Cycle) by enforcing a \"Filesystem Sovereignty\" model. It prevents \"Agent Drift\"\u2014where AI diverts from the original intent\u2014by requiring cryptographic seals on specifications before any implementation occurs.</p>"},{"location":"WHITE_PAPER/#the-role-architecture","title":"The Role Architecture","text":"<p>Aligning with modern Agentic patterns, GEAS defines a default team of five specialized agents to ensure separation of concerns:</p> <ul> <li> <p>The Spec Writer (Requirement Engineering): Translates ambiguity into rigid Gherkin-style intent.</p> </li> <li> <p>The Architect (DOMA Gatekeeper): Ensures new features respect domain boundaries and do not introduce structural debt.</p> </li> <li> <p>The Developer (Implementation): A narrow-focus agent that executes the sealed plan.</p> </li> <li> <p>The Doc Writer (Knowledge Management): Ensures the codebase remains intelligible to humans and future agents.</p> </li> <li> <p>The QA Engineer (Verification): The ultimate gatekeeper, validating that implementation matches the intent (MRP).</p> </li> </ul>"},{"location":"WHITE_PAPER/#the-core-axioms","title":"The Core Axioms","text":"<ol> <li> <p>Protocol over Platform: GEAS-AI is not a SaaS. It is a local protocol defined by file structures (.geas/).</p> </li> <li> <p>No Action Without Seal: Execution is cryptographically blocked until the Blueprint (02_specs.md) is approved.</p> </li> <li> <p>Separation of Infrastructure &amp; Intellect: Model configurations (models.yaml) are decoupled from Agent definitions (agents.yaml).</p> </li> </ol>"},{"location":"WHITE_PAPER/#the-architecture","title":"The Architecture","text":"<p>GEAS-AI operates on a \"Steering &amp; Engine\" model:</p> <ol> <li> <p>The Steering (GEAS CLI): A Python-based governance tool that manages the lifecycle of \"Bolts\" (Units of Work).</p> </li> <li> <p>The Engine (IDE Agent): Your existing AI tool (Antigravity, Cursor, Jules, etc.) acts as the runtime, reading GEAS-AI's state to determine its allowed actions.</p> </li> </ol>"},{"location":"WHITE_PAPER/#conclusion","title":"Conclusion","text":"<p>GEAS-AI provides the \"Guardrails\" for the AI era. It allows organizations to adopt autonomous agents while maintaining the strict auditability and quality standards required by enterprise software engineering.</p>"},{"location":"getting_started/","title":"Getting Started with GEAS-AI","text":"<p>Welcome to GEAS-AI (Governance Enforcement for Agentic Systems), the governance layer for Software Engineering 3.0. GEAS ensures that AI agents operate within a controlled, \"Spec-First\" environment, where every action is anchored in a cryptographically sealed blueprint.</p>"},{"location":"getting_started/#prerequisites","title":"\ud83d\udee0 Prerequisites","text":"<ul> <li>Python: 3.10 or higher.</li> <li>uv: We recommend using uv for fast and reliable package management.</li> </ul>"},{"location":"getting_started/#installation","title":"\ud83d\ude80 Installation","text":"<p>Install GEAS-AI using <code>uv</code>:</p> <pre><code>uv pip install geas-ai\n</code></pre> <p>Alternatively, you can run it directly without a permanent installation:</p> <pre><code>uv run geas --help\n</code></pre>"},{"location":"getting_started/#initializing-your-project","title":"\ud83c\udfd7 Initializing Your Project","text":"<p>To bootstrap GEAS in your repository, run:</p> <pre><code>geas init\n</code></pre> <p>This command creates a <code>.geas/</code> directory containing:</p> <ul> <li><code>config/agents.yaml</code>: Defines your AI team personas (Architect, Developer, QA, etc.) and their public keys.</li> <li><code>config/models.yaml</code>: Configures your LLM providers.</li> <li><code>bolts/</code>: The directory where all units of work (Bolts) will reside.</li> <li><code>active_context.md</code>: A pointer file indicating the current active Bolt.</li> </ul>"},{"location":"getting_started/#the-geas-workflow","title":"\u26a1\ufe0f The GEAS Workflow","text":"<p>GEAS enforces a rigorous lifecycle for every feature or bug fix, organized as a Bolt.</p>"},{"location":"getting_started/#1-create-a-new-bolt","title":"1. Create a New Bolt","text":"<p>Start a new unit of work:</p> <pre><code>geas new feature-name\n</code></pre> <p>This creates a folder in <code>.geas/bolts/feature-name/</code> and sets it as the active context.</p>"},{"location":"getting_started/#2-the-blueprinting-process","title":"2. The Blueprinting Process","text":"<p>Every Bolt follows a standard sequence:</p> <ol> <li>Request (<code>01_request.md</code>): Define the user's intent or feature request.</li> <li>Specs (<code>02_specs.md</code>): The Spec Writer agent translates the request into technical requirements.</li> <li>Plan (<code>03_plan.md</code>): The Architect agent designs the implementation plan.</li> </ol>"},{"location":"getting_started/#3-sealing-the-blueprint","title":"3. Sealing the Blueprint","text":"<p>Before any code is written, the artifacts must be \"sealed\" to ensure integrity:</p> <pre><code>geas seal specs\ngeas seal plan\n</code></pre> <p>Sealing hashes the content and records it in <code>approved.lock</code>. Once sealed, GEAS enforces that these files cannot be modified without being explicitly unsealed.</p>"},{"location":"getting_started/#4-implementation-and-verification","title":"4. Implementation and Verification","text":"<ol> <li>Code: The Developer executes the approved plan.</li> <li>MRP (<code>mrp/summary.md</code>): The QA Engineer verifies the output against the specs and seals the Master Release Plan.</li> </ol>"},{"location":"getting_started/#verification-and-status","title":"\ud83d\udee1 Verification and Status","text":"<p>At any point, you can check the status of your current Bolt:</p> <pre><code>geas status\n</code></pre> <p>Or verify the cryptographic integrity of all sealed artifacts:</p> <pre><code>geas verify\n</code></pre>"},{"location":"reference/","title":"API Reference","text":"<p>This section provides technical documentation for the internal GEAS-AI modules, automatically generated from the source code docstrings.</p>"},{"location":"reference/#core-commands","title":"Core Commands","text":""},{"location":"reference/#geas_ai.commands.init","title":"<code>geas_ai.commands.init</code>","text":""},{"location":"reference/#geas_ai.commands.init.init","title":"<code>init()</code>","text":"<p>Initialize the GEAS governance layer in the current directory.</p> <p>Creates the .geas/ directory structure and default configuration files. This includes config/agents.yaml, config/models.yaml, and GEAS_MANIFESTO.md.</p> Usage <p>$ geas init</p> Source code in <code>src/geas_ai/commands/init.py</code> <pre><code>def init() -&gt; None:\n    \"\"\"Initialize the GEAS governance layer in the current directory.\n\n    Creates the .geas/ directory structure and default configuration files.\n    This includes config/agents.yaml, config/models.yaml, and GEAS_MANIFESTO.md.\n\n    Usage:\n        $ geas init\n    \"\"\"\n    base_dir = \".geas\"\n\n    # 1. Check Pre-condition\n    if os.path.exists(base_dir):\n        console.print(\n            Panel(\n                \"[bold red]Error:[/bold red] GEAS is already initialized in this directory.\",\n                title=\"Initialization Failed\",\n            )\n        )\n        raise typer.Exit(code=1)\n\n    try:\n        # 2. Create Directory Structure\n        os.makedirs(os.path.join(base_dir, \"config\"), exist_ok=True)\n        os.makedirs(os.path.join(base_dir, \"bolts\"), exist_ok=True)\n        os.makedirs(os.path.join(base_dir, \"archive\"), exist_ok=True)\n\n        # 3. Create Configuration Files\n        with open(os.path.join(base_dir, \"config\", \"agents.yaml\"), \"w\") as f:\n            f.write(content.DEFAULT_AGENTS_YAML)\n\n        with open(os.path.join(base_dir, \"config\", \"models.yaml\"), \"w\") as f:\n            f.write(content.DEFAULT_MODELS_YAML)\n\n        # 4. Create Manifesto\n        with open(\"GEAS_MANIFESTO.md\", \"w\") as f:\n            f.write(content.MANIFESTO_CONTENT)\n\n        # 5. Success Message\n        console.print(\n            Panel(\n                f\"[bold green]Success![/bold green] GEAS initialized at [blue]{os.path.abspath(base_dir)}[/blue]\\n\\nCreated:\\n- .geas/config/agents.yaml\\n- .geas/config/models.yaml\\n- GEAS_MANIFESTO.md\",\n                title=\"GEAS Protocol\",\n            )\n        )\n\n    except Exception as e:\n        console.print(\n            f\"[bold red]An error occurred during initialization:[/bold red] {e}\"\n        )\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.lifecycle","title":"<code>geas_ai.commands.lifecycle</code>","text":""},{"location":"reference/#geas_ai.commands.lifecycle.archive","title":"<code>archive(name)</code>","text":"<p>Archive a fully verified bolt.</p> <p>A bolt can only be archived if all artifacts (req, specs, plan, mrp) are sealed and verified.</p> Usage <p>$ geas archive feature-completed</p> Source code in <code>src/geas_ai/commands/lifecycle.py</code> <pre><code>def archive(name: str) -&gt; None:\n    \"\"\"Archive a fully verified bolt.\n\n    A bolt can only be archived if all artifacts (req, specs, plan, mrp) are sealed\n    and verified.\n\n    Usage:\n        $ geas archive feature-completed\n    \"\"\"\n    utils.ensure_geas_root()\n    bolt_dir = utils.get_geas_root() / \"bolts\" / name\n    archive_root = utils.get_geas_root() / \"archive\"\n\n    if not bolt_dir.exists():\n        console.print(f\"[bold red]Error:[/bold red] Bolt '{name}' does not exist.\")\n        raise typer.Exit(code=1)\n\n    # 1. Verification\n    console.print(f\"Verifying bolt '{name}' before archival...\")\n    try:\n        # Run verify logic (will exit 1 if fails)\n        run_verify(bolt=name)\n\n        lock_file = bolt_dir / \"approved.lock\"\n        import yaml\n\n        with open(lock_file) as f:\n            data = yaml.safe_load(f) or {}\n\n        required = [\"req\", \"specs\", \"plan\", \"mrp\"]\n        missing = [r for r in required if f\"{r}_hash\" not in data]\n        if missing:\n            console.print(\n                f\"[bold red]Archival Rejected:[/bold red] The following artifacts are not sealed: {', '.join(missing)}\"\n            )\n            raise typer.Exit(code=1)\n\n    except (typer.Exit, SystemExit) as e:\n        exit_code = getattr(e, \"exit_code\", getattr(e, \"code\", 0))\n        if exit_code != 0:\n            console.print(\n                \"[bold red]Archival Rejected:[/bold red] Bolt failed verification.\"\n            )\n            raise typer.Exit(code=exit_code)\n    except Exception as e:\n        console.print(f\"[bold red]Error during archival check:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n\n    # 2. Move\n    try:\n        os.makedirs(archive_root, exist_ok=True)\n        target_path = archive_root / name\n\n        if target_path.exists():\n            console.print(\n                f\"[bold red]Error:[/bold red] Bolt '{name}' already exists in archive. Rename it or delete the archive version first.\"\n            )\n            raise typer.Exit(code=1)\n\n        shutil.move(str(bolt_dir), str(target_path))\n        console.print(\n            f\"[bold green]Success![/bold green] Bolt '{name}' moved to archive.\"\n        )\n\n    except Exception as e:\n        console.print(f\"[bold red]Error moving bolt to archive:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.lifecycle.checkout","title":"<code>checkout(name)</code>","text":"<p>Switch the current active context to a different bolt.</p> Usage <p>$ geas checkout feature-login</p> Source code in <code>src/geas_ai/commands/lifecycle.py</code> <pre><code>def checkout(name: str) -&gt; None:\n    \"\"\"Switch the current active context to a different bolt.\n\n    Usage:\n        $ geas checkout feature-login\n    \"\"\"\n    utils.ensure_geas_root()\n    bolt_dir = utils.get_geas_root() / \"bolts\" / name\n\n    if not bolt_dir.exists():\n        console.print(f\"[bold red]Error:[/bold red] Bolt '{name}' does not exist.\")\n        raise typer.Exit(code=1)\n\n    # Update active_context.md\n    ctx_path = utils.get_geas_root() / \"active_context.md\"\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    try:\n        with open(ctx_path, \"w\") as f:\n            f.write(\n                content.CONTEXT_TEMPLATE.format(bolt_name=name, timestamp=timestamp)\n            )\n\n        console.print(\n            Panel(\n                f\"[bold green]Switched to bolt:[/bold green] [blue]{name}[/blue]\",\n                title=\"geas checkout\",\n            )\n        )\n    except Exception as e:\n        console.print(f\"[bold red]Error updating context:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.lifecycle.delete","title":"<code>delete(name, force=typer.Option(False, '--force', '-f', help='Force deletion without confirmation'))</code>","text":"<p>Delete a bolt. Cannot delete the currently active bolt.</p> Usage <p>$ geas delete feature-obsolete</p> Source code in <code>src/geas_ai/commands/lifecycle.py</code> <pre><code>def delete(\n    name: str,\n    force: bool = typer.Option(\n        False, \"--force\", \"-f\", help=\"Force deletion without confirmation\"\n    ),\n) -&gt; None:\n    \"\"\"Delete a bolt. Cannot delete the currently active bolt.\n\n    Usage:\n        $ geas delete feature-obsolete\n    \"\"\"\n    utils.ensure_geas_root()\n\n    # Safety Check: Do not delete active bolt\n    try:\n        active_bolt = utils.get_active_bolt_name()\n        if name == active_bolt:\n            console.print(\n                f\"[bold red]Error:[/bold red] Cannot delete the active bolt '{name}'. Switch context first.\"\n            )\n            raise typer.Exit(code=1)\n    except Exception:\n        # If no active context, proceed with caution\n        pass\n\n    bolt_dir = utils.get_geas_root() / \"bolts\" / name\n    if not bolt_dir.exists():\n        console.print(f\"[bold red]Error:[/bold red] Bolt '{name}' does not exist.\")\n        raise typer.Exit(code=1)\n\n    if not force:\n        confirm = typer.confirm(f\"Are you sure you want to delete bolt '{name}'?\")\n        if not confirm:\n            raise typer.Abort()\n\n    try:\n        shutil.rmtree(bolt_dir)\n        console.print(f\"[bold green]Success:[/bold green] Bolt '{name}' deleted.\")\n    except Exception as e:\n        console.print(f\"[bold red]Error deleting bolt:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.lifecycle.new","title":"<code>new(name)</code>","text":"<p>Start a new GEAS Unit of Work (Bolt).</p> <p>Creates .geas/bolts// and updates .geas/active_context.md. <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the bolt (slugified).</p> required Usage <p>$ geas new feature-login</p> Source code in <code>src/geas_ai/commands/lifecycle.py</code> <pre><code>def new(name: str) -&gt; None:\n    \"\"\"Start a new GEAS Unit of Work (Bolt).\n\n    Creates .geas/bolts/&lt;name&gt;/ and updates .geas/active_context.md.\n\n    Args:\n        name: The name of the bolt (slugified).\n\n    Usage:\n        $ geas new feature-login\n    \"\"\"\n    try:\n        # 1. Validation\n        utils.ensure_geas_root()\n        utils.validate_slug(name)\n\n        bolt_dir = os.path.join(\".geas\", \"bolts\", name)\n\n        # 2. Check for existence (Idempotencyish warning)\n        if os.path.exists(bolt_dir):\n            console.print(f\"[bold red]Error:[/bold red] Bolt '{name}' already exists.\")\n            raise typer.Exit(code=1)\n\n        # 3. Create Structure\n        os.makedirs(bolt_dir)\n\n        # 4. Create Request File\n        req_path = os.path.join(bolt_dir, \"01_request.md\")\n        with open(req_path, \"w\") as f:\n            f.write(content.REQUEST_TEMPLATE.format(bolt_name=name))\n\n        # 5. Update Context\n        ctx_path = os.path.join(\".geas\", \"active_context.md\")\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        with open(ctx_path, \"w\") as f:\n            f.write(\n                content.CONTEXT_TEMPLATE.format(bolt_name=name, timestamp=timestamp)\n            )\n\n        # 6. Success Output\n        console.print(\n            Panel(\n                f\"[bold green]Bolt Started![/bold green]\\n\\nWorkspace: [blue]{bolt_dir}[/blue]\\nContext: [yellow]Updated[/yellow]\",\n                title=f\"Bolt: {name}\",\n            )\n        )\n\n    except Exception as e:\n        # If it's a Typer Exit, just re-raise\n        if isinstance(e, typer.Exit) or isinstance(e, typer.BadParameter):\n            raise e\n        console.print(f\"[bold red]Unexpected Error:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.seal","title":"<code>geas_ai.commands.seal</code>","text":""},{"location":"reference/#geas_ai.commands.seal.seal","title":"<code>seal(target=typer.Argument(..., help='Target to seal [req, specs, plan, mrp]'))</code>","text":"<p>Cryptographically seal the current Bolt's artifacts.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The artifact to seal.</p> <code>Argument(..., help='Target to seal [req, specs, plan, mrp]')</code> Usage <p>$ geas seal req $ geas seal specs</p> Source code in <code>src/geas_ai/commands/seal.py</code> <pre><code>def seal(\n    target: str = typer.Argument(..., help=\"Target to seal [req, specs, plan, mrp]\"),\n) -&gt; None:\n    \"\"\"Cryptographically seal the current Bolt's artifacts.\n\n    Args:\n        target: The artifact to seal.\n\n    Usage:\n        $ geas seal req\n        $ geas seal specs\n    \"\"\"\n    utils.ensure_geas_root()\n    bolt_path = utils.get_active_bolt_path()\n    lock_file = bolt_path / \"approved.lock\"\n\n    # --- Main Logic: Sealing ---\n    valid_targets = {\n        \"req\": \"01_request.md\",\n        \"specs\": \"02_specs.md\",\n        \"plan\": \"03_plan.md\",\n        \"mrp\": \"mrp/summary.md\",\n    }\n\n    if target not in valid_targets:\n        console.print(\n            f\"[bold red]Error:[/bold red] Invalid target '{target}'. Use: req, specs, plan, mrp\"\n        )\n        raise typer.Exit(code=1)\n\n    target_file = bolt_path / valid_targets[target]\n\n    if not target_file.exists():\n        console.print(f\"[bold red]Error:[/bold red] File not found: {target_file}\")\n        raise typer.Exit(code=1)\n\n    # Calculate Hash\n    new_hash = utils.compute_sha256(target_file)\n    timestamp = datetime.now().isoformat()\n\n    # Update Lock\n    lock_data: dict[str, str] = {}\n    if lock_file.exists():\n        with open(lock_file) as f:\n            lock_data = yaml.safe_load(f) or {}\n\n    lock_data[f\"{target}_hash\"] = new_hash\n    lock_data[f\"{target}_sealed_at\"] = timestamp\n\n    with open(lock_file, \"w\") as f:\n        yaml.safe_dump(lock_data, f)\n\n    console.print(\n        Panel(\n            f\"[bold green]Sealed {target}![/bold green]\\nHash: {new_hash[:12]}...\",\n            title=\"GEAS Seal\",\n        )\n    )\n</code></pre>"},{"location":"reference/#geas_ai.commands.status","title":"<code>geas_ai.commands.status</code>","text":""},{"location":"reference/#geas_ai.commands.status.status","title":"<code>status(bolt=typer.Option(None, '--bolt', '-b', help='Name of the bolt to check status for'))</code>","text":"<p>Display the current seal status of a bolt.</p> Usage <p>$ geas status $ geas status -b feature-login</p> Source code in <code>src/geas_ai/commands/status.py</code> <pre><code>def status(\n    bolt: Optional[str] = typer.Option(\n        None, \"--bolt\", \"-b\", help=\"Name of the bolt to check status for\"\n    ),\n) -&gt; None:\n    \"\"\"Display the current seal status of a bolt.\n\n    Usage:\n        $ geas status\n        $ geas status -b feature-login\n    \"\"\"\n    utils.ensure_geas_root()\n\n    if bolt:\n        bolt_path = utils.get_geas_root() / \"bolts\" / bolt\n        if not bolt_path.exists():\n            console.print(f\"[bold red]Error:[/bold red] Bolt '{bolt}' not found.\")\n            raise typer.Exit(code=1)\n    else:\n        bolt_path = utils.get_active_bolt_path()\n\n    lock_file = bolt_path / \"approved.lock\"\n\n    if not lock_file.exists():\n        console.print(\n            f\"[yellow]No approved.lock found for bolt '{bolt_path.name}'.[/yellow]\"\n        )\n        return\n\n    try:\n        with open(lock_file) as f:\n            data = yaml.safe_load(f) or {}\n\n        table = Table(title=f\"Seal Status: {bolt_path.name}\")\n        table.add_column(\"Artifact\", style=\"cyan\")\n        table.add_column(\"Sealed At\", style=\"green\")\n        table.add_column(\"Hash (Prefix)\", style=\"dim\")\n\n        for key in [\"req\", \"specs\", \"plan\", \"mrp\"]:\n            ts = data.get(f\"{key}_sealed_at\", \"-\")\n            h = data.get(f\"{key}_hash\", \"\")\n            table.add_row(key, ts, h[:8] if h else \"-\")\n\n        console.print(table)\n    except Exception as e:\n        console.print(f\"[bold red]Error reading lock file:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.verify","title":"<code>geas_ai.commands.verify</code>","text":""},{"location":"reference/#geas_ai.commands.verify.verify","title":"<code>verify(bolt=typer.Option(None, '--bolt', '-b', help='Name of the bolt to verify'))</code>","text":"<p>Verify the cryptographic integrity and temporal sequence of a bolt.</p> Usage <p>$ geas verify $ geas verify -b feature-login</p> Source code in <code>src/geas_ai/commands/verify.py</code> <pre><code>def verify(\n    bolt: Optional[str] = typer.Option(\n        None, \"--bolt\", \"-b\", help=\"Name of the bolt to verify\"\n    ),\n) -&gt; None:\n    \"\"\"Verify the cryptographic integrity and temporal sequence of a bolt.\n\n    Usage:\n        $ geas verify\n        $ geas verify -b feature-login\n    \"\"\"\n    utils.ensure_geas_root()\n\n    if bolt:\n        bolt_path = utils.get_geas_root() / \"bolts\" / bolt\n        if not bolt_path.exists():\n            console.print(f\"[bold red]Error:[/bold red] Bolt '{bolt}' not found.\")\n            raise typer.Exit(code=1)\n    else:\n        bolt_path = utils.get_active_bolt_path()\n\n    lock_file = bolt_path / \"approved.lock\"\n\n    if not lock_file.exists():\n        console.print(\n            f\"[bold red]Fail:[/bold red] No lock file found for bolt '{bolt_path.name}'.\"\n        )\n        raise typer.Exit(code=1)\n\n    try:\n        with open(lock_file) as f:\n            data = yaml.safe_load(f) or {}\n\n        table = Table(title=f\"Verification: {bolt_path.name}\")\n        table.add_column(\"Artifact\", style=\"cyan\")\n        table.add_column(\"Status\", style=\"bold\")\n\n        artifacts_map = {\n            \"req\": \"01_request.md\",\n            \"specs\": \"02_specs.md\",\n            \"plan\": \"03_plan.md\",\n            \"mrp\": \"mrp/summary.md\",\n        }\n\n        all_passed = True\n        seal_times: list[datetime | None] = []\n\n        # 1. Integrity Check\n        for key, filename in artifacts_map.items():\n            stored_hash = data.get(f\"{key}_hash\")\n            sealed_at = data.get(f\"{key}_sealed_at\")\n\n            if not stored_hash:\n                table.add_row(key, \"[dim]Not Sealed[/dim]\")\n                seal_times.append(None)\n                continue\n\n            # Track timestamp for sequence check\n            try:\n                dt = datetime.fromisoformat(str(sealed_at))\n                seal_times.append(dt)\n            except (ValueError, TypeError):\n                seal_times.append(None)\n\n            file_path = bolt_path / filename\n            if not file_path.exists():\n                table.add_row(key, \"[red]Missing File[/red]\")\n                all_passed = False\n                continue\n\n            current_hash = utils.compute_sha256(file_path)\n            if current_hash == stored_hash:\n                table.add_row(key, \"[green]PASS[/green]\")\n            else:\n                table.add_row(key, \"[red]FAIL (Drift Detected)[/red]\")\n                all_passed = False\n\n        console.print(table)\n\n        # 2. Sequence Verification\n        valid_sequence = True\n        # Filter out None values for comparison\n        active_times = [\n            (artifacts_map[list(artifacts_map.keys())[i]], t)\n            for i, t in enumerate(seal_times)\n            if t is not None\n        ]\n\n        for i in range(len(active_times) - 1):\n            if active_times[i][1] &gt; active_times[i + 1][1]:\n                console.print(\n                    f\"[bold red]Sequence Error:[/bold red] {active_times[i][0]} was sealed AFTER {active_times[i + 1][0]}.\"\n                )\n                valid_sequence = False\n\n        if not valid_sequence:\n            all_passed = False\n\n        if not all_passed:\n            raise typer.Exit(code=1)\n        else:\n            console.print(\n                \"[bold green]Success:[/bold green] All artifacts verified and sequence is correct.\"\n            )\n\n    except Exception as e:\n        if isinstance(e, typer.Exit):\n            raise e\n        console.print(f\"[bold red]Error during verification:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.agents","title":"<code>geas_ai.commands.agents</code>","text":""},{"location":"reference/#geas_ai.commands.agents.agents","title":"<code>agents()</code>","text":"<p>List the currently active agents configuration.</p> Source code in <code>src/geas_ai/commands/agents.py</code> <pre><code>def agents() -&gt; None:\n    \"\"\"List the currently active agents configuration.\"\"\"\n    utils.ensure_geas_root()\n\n    # Read from global .geas/config/agents.yaml\n    config_path = utils.get_geas_root() / \"config/agents.yaml\"\n\n    if not config_path.exists():\n        utils.console.print(\n            f\"[bold red]Error:[/bold red] Agent configuration not found at {config_path}\"\n        )\n        raise typer.Exit(code=1)\n\n    try:\n        with open(config_path, \"r\", encoding=\"utf-8\") as f:\n            data = yaml.safe_load(f)\n    except Exception as e:\n        utils.console.print(\n            f\"[bold red]Error:[/bold red] Failed to parse agents.yaml: {e}\"\n        )\n        raise typer.Exit(code=1)\n\n    if not data or \"agents\" not in data:\n        utils.console.print(\n            \"[bold yellow]Warning:[/bold yellow] No agents defined in agents.yaml\"\n        )\n        return\n\n    table = Table(title=\"GEAS Agents Roster (Global)\")\n    table.add_column(\"Agent Name\", style=\"cyan\", no_wrap=True)\n    table.add_column(\"Role\", style=\"magenta\")\n    table.add_column(\"Goal\", style=\"green\")\n\n    # Sort agents for consistent display\n    for agent_name, agent_info in sorted(data[\"agents\"].items()):\n        role = agent_info.get(\"role\", \"N/A\")\n        goal = agent_info.get(\"goal\", \"N/A\")\n        table.add_row(agent_name, role, goal)\n\n    utils.console.print(table)\n</code></pre>"}]}