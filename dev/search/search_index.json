{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"GEAS-AI Documentation","text":"<p>Welcome to the official documentation for GEAS-AI (Governance Enforcement for Agentic Systems).</p>"},{"location":"#quick-links","title":"\ud83c\udfc1 Quick Links","text":"<ul> <li>Getting Started: Your guide to installing and running your first GEAS Bolt.</li> <li>About: Learn more about GEAS-AI.</li> <li>API Reference: Learn how to use GEAS-AI in your projects.</li> </ul>"},{"location":"#commands","title":"\ud83d\udee0 Commands","text":"<ul> <li><code>geas init</code> - Initialize GEAS in a project.</li> <li><code>geas new &lt;name&gt;</code> - Create a new unit of work (Bolt).</li> <li><code>geas seal &lt;target&gt;</code> - Seal a blueprint artifact.</li> <li><code>geas verify</code> - Verify the integrity of the active Bolt.</li> <li><code>geas status</code> - Show the current governance status.</li> </ul>"},{"location":"AGENT_CONTEXT/","title":"GEAS-AI Repository Context for Agents","text":"<p>Document Version: 3.0 Last Updated: 2026-01-03 Purpose: Provide comprehensive context for AI agents working on the GEAS-AI codebase.</p>"},{"location":"AGENT_CONTEXT/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Executive Summary</li> <li>Repository Overview</li> <li>Architecture</li> <li>Directory Structure</li> <li>Technology Stack</li> <li>Naming Conventions</li> <li>Code Quality Standards</li> <li>Development Workflow</li> <li>Testing Guidelines</li> <li>CLI Command Reference</li> <li>Key Concepts &amp; Domain Vocabulary</li> <li>File Templates &amp; Schemas</li> <li>CI/CD Pipeline</li> <li>Agent Personas</li> <li>Current Development Status</li> <li>Critical Rules for Agents</li> </ol>"},{"location":"AGENT_CONTEXT/#executive-summary","title":"Executive Summary","text":"<p>GEAS-AI (Governance Enforcement for Agent Systems) is a repository-native governance protocol for AI-driven software development. It enforces a \"Spec-First\" workflow where:</p> <ul> <li>Intent documents (specs, plans) are cryptographically sealed before code is written.</li> <li>Code remains freely mutable during development.</li> <li>Evidence (the MRP - Merge Request Package) is sealed after tests pass.</li> </ul> <p>The protocol creates non-repudiable, tamper-evident proof of the entire development lifecycle using Ed25519 cryptographic signatures.</p>"},{"location":"AGENT_CONTEXT/#core-philosophy","title":"Core Philosophy","text":"<p>\"A Geas is a magical obligation. If the hero breaks the vow, they lose their power.\"</p> <p>In GEAS:</p> Element Meaning The Hero The AI Agent(s) The Vow The Intent Documents (requirements, specs, plan) The Power The ability to merge code"},{"location":"AGENT_CONTEXT/#why-geas-over-git","title":"Why GEAS over Git?","text":"<p>Git provides versioning, but Git authorship is trivially spoofable. GEAS adds cryptographic non-repudiation:</p> Capability Git GEAS Track changes \u2705 \u2705 Author attribution \u26a0\ufe0f Spoofable \u2705 Ed25519 signatures Intent-to-code binding \u274c \u2705 Sealed specs \u2192 manifest Prove tests passed for code version X \u274c \u2705 MRP with test logs + code snapshot Role-based workflow enforcement \u274c \u2705 Configurable stages"},{"location":"AGENT_CONTEXT/#repository-overview","title":"Repository Overview","text":"Attribute Value Package Name <code>geas-ai</code> Current Version <code>0.1.3</code> (Alpha) Python Version <code>&gt;=3.10</code> License Dual MIT / Apache-2.0 Package Manager <code>uv</code> CLI Entry Point <code>geas</code> (\u2192 <code>geas_ai.main:main</code>) Documentation MkDocs (Material theme) Primary Author Raul De Maio"},{"location":"AGENT_CONTEXT/#architecture","title":"Architecture","text":""},{"location":"AGENT_CONTEXT/#high-level-design-steering-engine","title":"High-Level Design: \"Steering &amp; Engine\"","text":"<p>GEAS consists of two components:</p> Component Role Examples The Steering (Protocol) The <code>geas</code> CLI manages Bolt lifecycles and acts as the notary. <code>geas new</code>, <code>geas seal</code>, <code>geas prove</code> The Engine (Agent) Your existing AI tool acts as the runtime. It reads GEAS state to understand its boundaries. Cursor, Windsurf, Aider, Claude Code"},{"location":"AGENT_CONTEXT/#the-trinity-lock","title":"The Trinity Lock","text":"<p>The cryptographic engine binds three pillars:</p> Pillar Concept Implementation Physical Integrity \"The content hasn't changed.\" SHA-256 hashes / Merkle Trees Identity \"We know who authorized this.\" Ed25519 Signatures (SSH format) Audit History \"We know the sequence of events.\" Hash-Chain Ledger (<code>lock.json</code>)"},{"location":"AGENT_CONTEXT/#lifecycle-diagram","title":"Lifecycle Diagram","text":"<pre><code>graph TD\n    subgraph Intent [\"Intent Phase\"]\n        Req[01_request.md] --&gt; Specs[02_specs.md]\n        Specs --&gt; Plan[03_plan.md]\n        Plan --&gt; SealIntent((Seal Intent))\n    end\n\n    subgraph Implementation [\"Code Phase\"]\n        SealIntent --&gt; Code[Source Code]\n        Code --&gt; Tests{Pass Tests?}\n        Tests -- No --&gt; Code\n        Tests -- Yes --&gt; Prove((Prove))\n    end\n\n    subgraph Verification [\"MRP Phase\"]\n        Prove --&gt; Artifacts[Manifest + Logs]\n        Artifacts --&gt; MRP[mrp/summary.md]\n        MRP --&gt; SealMRP((Seal MRP))\n        SealMRP --&gt; Verify{Verify Chain}\n        Verify -- Valid --&gt; Approve((Approve))\n    end\n</code></pre>"},{"location":"AGENT_CONTEXT/#locking-scope","title":"Locking Scope","text":"Layer Content Lock State INTENT <code>01_request.md</code>, <code>02_specs.md</code>, <code>03_plan.md</code> Immutable after seal CODE <code>src/</code>, <code>tests/</code> Mutable (evolves freely) MRP <code>mrp/summary.md</code>, <code>mrp/tests.log</code>, <code>mrp/manifest.json</code> Immutable after seal"},{"location":"AGENT_CONTEXT/#directory-structure","title":"Directory Structure","text":"<pre><code>geas-ai/\n\u251c\u2500\u2500 .geas/                          # GEAS Protocol Directory\n\u2502   \u251c\u2500\u2500 active_context.md           # Current bolt pointer\n\u2502   \u251c\u2500\u2500 archive/                    # Completed bolts\n\u2502   \u251c\u2500\u2500 bolts/                      # Active work units\n\u2502   \u2502   \u2514\u2500\u2500 &lt;bolt-name&gt;/\n\u2502   \u2502       \u251c\u2500\u2500 01_request.md       # Feature request\n\u2502   \u2502       \u251c\u2500\u2500 02_specs.md         # Specifications\n\u2502   \u2502       \u251c\u2500\u2500 03_plan.md          # Implementation plan\n\u2502   \u2502       \u251c\u2500\u2500 approved.lock       # Cryptographic ledger (YAML)\n\u2502   \u2502       \u2514\u2500\u2500 mrp/                # Merge Request Package\n\u2502   \u2502           \u251c\u2500\u2500 summary.md\n\u2502   \u2502           \u251c\u2500\u2500 tests.log\n\u2502   \u2502           \u2514\u2500\u2500 manifest.json\n\u2502   \u2514\u2500\u2500 config/\n\u2502       \u251c\u2500\u2500 agents.yaml             # Agent persona definitions\n\u2502       \u251c\u2500\u2500 models.yaml             # LLM provider configs\n\u2502       \u251c\u2500\u2500 identities.yaml         # Cryptographic identities\n\u2502       \u2514\u2500\u2500 workflow.yaml           # Governance rules\n\u2502\n\u251c\u2500\u2500 src/geas_ai/                    # Source Code\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 main.py                     # CLI entry point (Typer app)\n\u2502   \u251c\u2500\u2500 utils.py                    # Utility functions\n\u2502   \u251c\u2500\u2500 commands/                   # CLI command modules\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u251c\u2500\u2500 init.py                 # `geas init`\n\u2502   \u2502   \u251c\u2500\u2500 lifecycle.py            # `geas new`, `checkout`, `delete`, `archive`\n\u2502   \u2502   \u251c\u2500\u2500 seal.py                 # `geas seal`\n\u2502   \u2502   \u251c\u2500\u2500 prove.py                # `geas prove`\n\u2502   \u2502   \u251c\u2500\u2500 approve.py              # `geas approve`\n\u2502   \u2502   \u251c\u2500\u2500 status.py               # `geas status`\n\u2502   \u2502   \u251c\u2500\u2500 verify.py               # `geas verify`\n\u2502   \u2502   \u2514\u2500\u2500 agents.py               # `geas agents`\n\u2502   \u2514\u2500\u2500 core/\n\u2502       \u251c\u2500\u2500 __init__.py\n\u2502       \u2514\u2500\u2500 content.py              # Templates and default content\n\u2502\n\u251c\u2500\u2500 tests/                          # Test Suite\n\u2502   \u251c\u2500\u2500 conftest.py                 # Pytest fixtures\n\u2502   \u251c\u2500\u2500 test_core.py                # Core CLI tests\n\u2502   \u2514\u2500\u2500 test_agents.py              # Agent-related tests\n\u2502\n\u251c\u2500\u2500 docs/                           # Documentation (MkDocs)\n\u2502   \u251c\u2500\u2500 WHITE_PAPER.md              # Protocol specification\n\u2502   \u251c\u2500\u2500 TRINITY_LOCK.md             # Cryptographic specification\n\u2502   \u251c\u2500\u2500 AGENT_CONTEXT.md            # This document\n\u2502   \u251c\u2500\u2500 getting_started.md          # User guide\n\u2502   \u2514\u2500\u2500 reference.md                # API reference\n\u2502\n\u251c\u2500\u2500 strategic_docs/                 # Strategic planning\n\u2502   \u2514\u2500\u2500 ROADMAP.md                  # Development roadmap\n\u2502\n\u251c\u2500\u2500 .github/workflows/              # CI/CD\n\u2502   \u251c\u2500\u2500 ci.yml                      # Test &amp; lint pipeline\n\u2502   \u251c\u2500\u2500 docs.yml                    # Documentation deployment\n\u2502   \u2514\u2500\u2500 publish.yml                 # PyPI publication\n\u2502\n\u2514\u2500\u2500 Configuration Files\n    \u251c\u2500\u2500 pyproject.toml              # Project metadata &amp; dependencies\n    \u251c\u2500\u2500 .pre-commit-config.yaml     # Pre-commit hooks\n    \u251c\u2500\u2500 mkdocs.yml                  # Documentation config\n    \u2514\u2500\u2500 uv.lock                     # Dependency lock file\n</code></pre>"},{"location":"AGENT_CONTEXT/#technology-stack","title":"Technology Stack","text":"Category Technology Purpose Language Python 3.10+ Core implementation Package Manager <code>uv</code> Fast dependency management CLI Framework <code>typer</code> Type-hinted CLI Output Formatting <code>rich</code> Terminal formatting &amp; tables YAML Parsing <code>pyyaml</code> Configuration parsing Linting <code>ruff</code> Fast Python linter/formatter Type Checking <code>mypy</code> (strict mode) Static type analysis Testing <code>pytest</code> Test framework Pre-commit <code>pre-commit</code> Git hook management Documentation <code>mkdocs-material</code> Documentation site Cryptography <code>cryptography</code> Ed25519 signatures"},{"location":"AGENT_CONTEXT/#dependency-groups","title":"Dependency Groups","text":"<pre><code>[project]\ndependencies = [\n    \"pre-commit&gt;=4.5.1\",\n    \"pyyaml&gt;=6.0.3\",\n    \"rich&gt;=14.2.0\",\n    \"typer&gt;=0.21.0\",\n]\n\n[dependency-groups]\ndev = [\"mypy&gt;=1.19.1\", \"pre-commit&gt;=4.5.1\", \"pytest&gt;=9.0.2\", \"ruff&gt;=0.14.10\"]\ndocs = [\"mike&gt;=2.1.3\", \"mkdocs&gt;=1.6.1\", \"mkdocs-material&gt;=9.7.1\", \"mkdocstrings[python]&gt;=1.0.0\"]\n</code></pre>"},{"location":"AGENT_CONTEXT/#naming-conventions","title":"Naming Conventions","text":""},{"location":"AGENT_CONTEXT/#file-naming","title":"File Naming","text":"Context Convention Examples Python modules <code>snake_case.py</code> <code>lifecycle.py</code>, <code>content.py</code> Test files <code>test_&lt;module&gt;.py</code> <code>test_core.py</code>, <code>test_agents.py</code> Config files <code>&lt;name&gt;.yaml</code> <code>agents.yaml</code>, <code>models.yaml</code> Intent documents <code>&lt;NN&gt;_&lt;name&gt;.md</code> <code>01_request.md</code>, <code>02_specs.md</code>, <code>03_plan.md</code> Bolt folders <code>kebab-case</code> or <code>snake_case</code> <code>feature-login</code>, <code>step_1_identity</code> Lock files <code>approved.lock</code> (YAML) or <code>lock.json</code> (JSON)"},{"location":"AGENT_CONTEXT/#python-naming","title":"Python Naming","text":"Element Convention Example Variables <code>snake_case</code> <code>bolt_path</code>, <code>lock_data</code> Functions <code>snake_case</code> <code>get_active_bolt_path()</code>, <code>compute_sha256()</code> Classes <code>PascalCase</code> <code>Console</code>, <code>Table</code> Constants <code>SCREAMING_SNAKE_CASE</code> <code>DEFAULT_AGENTS_YAML</code>, <code>REQUEST_TEMPLATE</code> Type hints Required on all functions <code>def new(name: str) -&gt; None:</code> Private functions <code>_leading_underscore</code> <code>_validate_config()</code>"},{"location":"AGENT_CONTEXT/#cli-commands","title":"CLI Commands","text":"Pattern Example Top-level verbs <code>geas init</code>, <code>geas new</code>, <code>geas seal</code> Kebab-case slugs <code>geas new feature-login</code> Flags with short forms <code>--force/-f</code>, <code>--bolt/-b</code>"},{"location":"AGENT_CONTEXT/#slug-validation-rules","title":"Slug Validation Rules","text":"<p>Bolt names must follow this regex pattern: <code>^[a-z0-9-_]+$</code></p> <ul> <li>Only lowercase letters, numbers, hyphens, and underscores</li> <li>No spaces or special characters</li> <li>Examples: <code>feature-login</code>, <code>step_1_identity</code>, <code>bugfix-auth</code></li> </ul>"},{"location":"AGENT_CONTEXT/#code-quality-standards","title":"Code Quality Standards","text":""},{"location":"AGENT_CONTEXT/#type-hints-strict-mandatory","title":"Type Hints (Strict - MANDATORY)","text":"<p>All functions MUST have complete type annotations:</p> <pre><code>def compute_sha256(file_path: Path) -&gt; str:\n    \"\"\"Computes SHA256 hash of the file content (normalized).\"\"\"\n    ...\n</code></pre>"},{"location":"AGENT_CONTEXT/#docstrings-google-style-mandatory","title":"Docstrings (Google Style - MANDATORY)","text":"<p>All public functions require docstrings with:</p> <ul> <li>Description</li> <li>Args (if any)</li> <li>Returns (if applicable)</li> <li>Usage example (preferred)</li> </ul> <pre><code>def new(name: str) -&gt; None:\n    \"\"\"Start a new GEAS Unit of Work (Bolt).\n\n    Creates .geas/bolts/&lt;name&gt;/ and updates .geas/active_context.md.\n\n    Args:\n        name: The name of the bolt (slugified).\n\n    Usage:\n        $ geas new feature-login\n    \"\"\"\n</code></pre>"},{"location":"AGENT_CONTEXT/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>The repository enforces these hooks automatically:</p> <pre><code>hooks:\n  - id: trailing-whitespace     # Remove trailing whitespace\n  - id: end-of-file-fixer       # Ensure files end with newline\n  - id: check-yaml              # Validate YAML syntax\n  - id: check-added-large-files # Prevent large files\n  - id: ruff                    # Linting with --fix\n  - id: ruff-format             # Code formatting\n  - id: mypy                    # Type checking (--strict)\n</code></pre>"},{"location":"AGENT_CONTEXT/#error-handling-pattern","title":"Error Handling Pattern","text":"<p>Use <code>typer.Exit(code=1)</code> for controlled CLI failures:</p> <pre><code>if not bolt_dir.exists():\n    console.print(f\"[bold red]Error:[/bold red] Bolt '{name}' does not exist.\")\n    raise typer.Exit(code=1)\n</code></pre>"},{"location":"AGENT_CONTEXT/#dry-principle","title":"DRY Principle","text":"<p>Extract repeated logic immediately. Use utility functions from <code>src/geas_ai/utils.py</code>:</p> Function Purpose <code>get_geas_root()</code> Returns Path to <code>.geas</code> directory <code>ensure_geas_root()</code> Validates GEAS is initialized <code>validate_slug(name)</code> Validates bolt name format <code>compute_sha256(file_path)</code> Compute normalized SHA-256 hash <code>get_active_bolt_path()</code> Get current bolt's Path <code>get_active_bolt_name()</code> Get current bolt's name"},{"location":"AGENT_CONTEXT/#development-workflow","title":"Development Workflow","text":""},{"location":"AGENT_CONTEXT/#geas-protocol-workflow","title":"GEAS Protocol Workflow","text":"<pre><code>1. geas new &lt;bolt-name&gt;       # Create workspace\n2. Edit 01_request.md         # Define requirements\n3. geas seal req              # Seal request\n4. Create 02_specs.md         # Define specifications\n5. geas seal specs            # Seal specs\n6. Create 03_plan.md          # Define implementation plan\n7. geas seal plan             # Seal plan\n8. geas seal intent           # Sign full intent (optional/required by policy)\n9. Implement in src/          # Write code (mutable)\n10. geas prove                # Run tests &amp; generate manifest\n11. geas seal mrp             # Seal MRP\n12. geas verify               # Validate chain\n13. geas approve              # Approve for merge\n14. geas archive &lt;bolt-name&gt;  # Archive completed bolt\n</code></pre>"},{"location":"AGENT_CONTEXT/#seal-sequence-enforcement","title":"Seal Sequence Enforcement","text":"<p>The <code>geas verify</code> command enforces this seal order:</p> <ol> <li><code>req</code> \u2192 <code>specs</code> \u2192 <code>plan</code> \u2192 <code>mrp</code></li> </ol> <p>A bolt cannot be archived unless all four artifacts are sealed AND verified.</p>"},{"location":"AGENT_CONTEXT/#git-workflow","title":"Git Workflow","text":"<ol> <li>Create feature branch</li> <li>Follow GEAS lifecycle above</li> <li>Ensure all tests pass: <code>uv run pytest</code></li> <li>Ensure linting passes: <code>uv run ruff check .</code></li> <li>Submit PR</li> </ol>"},{"location":"AGENT_CONTEXT/#local-development-setup","title":"Local Development Setup","text":"<pre><code># Clone and setup\ngit clone &lt;repo-url&gt;\ncd geas-ai\n\n# Sync environment\nuv sync\n\n# Install pre-commit hooks\nuv run pre-commit install\n\n# Run tests\nuv run pytest\n\n# Run linting\nuv run ruff check .\nuv run ruff format --check .\nuv run mypy src\n</code></pre>"},{"location":"AGENT_CONTEXT/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"AGENT_CONTEXT/#framework-structure","title":"Framework &amp; Structure","text":"<ul> <li>Framework: <code>pytest</code></li> <li>Location: <code>tests/</code></li> <li>Fixtures: <code>tests/conftest.py</code></li> </ul>"},{"location":"AGENT_CONTEXT/#coverage-target","title":"Coverage Target","text":"<p>&gt;85% code coverage is required.</p>"},{"location":"AGENT_CONTEXT/#test-patterns","title":"Test Patterns","text":"<pre><code># Fixture for temporary GEAS environment\n@pytest.fixture\ndef setup_geas_environment(tmp_path):\n    \"\"\"Sets up a temporary GEAS environment.\"\"\"\n    geas_dir = tmp_path / \".geas\"\n    geas_dir.mkdir()\n    config_dir = geas_dir / \"config\"\n    config_dir.mkdir()\n    # ... setup ...\n    cwd = os.getcwd()\n    os.chdir(tmp_path)\n    yield tmp_path\n    os.chdir(cwd)\n</code></pre> <pre><code># CLI test using CliRunner\ndef test_init_command(runner, tmp_path):\n    \"\"\"Test 'geas init' creates the necessary structure.\"\"\"\n    cwd = os.getcwd()\n    os.chdir(tmp_path)\n    try:\n        result = runner.invoke(app, [\"init\"])\n        assert result.exit_code == 0\n        assert \"Success! GEAS initialized\" in result.stdout\n        assert (tmp_path / \".geas\").exists()\n    finally:\n        os.chdir(cwd)\n</code></pre>"},{"location":"AGENT_CONTEXT/#test-categories","title":"Test Categories","text":"Category Purpose Unit tests Test individual functions/modules Integration tests Test CLI command workflows Seal/Verify tests Test cryptographic integrity"},{"location":"AGENT_CONTEXT/#tdd-approach","title":"TDD Approach","text":"<ol> <li>Write tests BEFORE implementation</li> <li>Tests must cover happy paths, edge cases, and failure modes</li> <li>Never commit code without passing tests</li> </ol>"},{"location":"AGENT_CONTEXT/#cli-command-reference","title":"CLI Command Reference","text":"Command Purpose Example <code>geas init</code> Initialize GEAS in repository <code>geas init</code> <code>geas new &lt;name&gt;</code> Create new bolt workspace <code>geas new feature-login</code> <code>geas checkout &lt;name&gt;</code> Switch active bolt context <code>geas checkout feature-login</code> <code>geas seal &lt;target&gt;</code> Seal artifact (req, specs, plan, mrp, intent) <code>geas seal specs</code> <code>geas prove</code> Run tests and generate Code Manifest <code>geas prove</code> <code>geas status</code> Display current bolt status <code>geas status</code> <code>geas verify</code> Verify bolt integrity &amp; sequence <code>geas verify</code> <code>geas approve</code> Approve a sealed MRP for merge <code>geas approve --identity lead</code> <code>geas delete &lt;name&gt;</code> Delete a bolt <code>geas delete old-feature</code> <code>geas archive &lt;name&gt;</code> Archive completed bolt <code>geas archive feature-login</code> <code>geas agents</code> List available agent personas <code>geas agents</code> <code>geas version</code> Show GEAS version <code>geas version</code>"},{"location":"AGENT_CONTEXT/#seal-targets","title":"Seal Targets","text":"Target File <code>req</code> <code>01_request.md</code> <code>specs</code> <code>02_specs.md</code> <code>plan</code> <code>03_plan.md</code> <code>mrp</code> <code>mrp/summary.md</code> <code>intent</code> All 3 documents (sealed together)"},{"location":"AGENT_CONTEXT/#command-exit-codes","title":"Command Exit Codes","text":"Code Meaning <code>0</code> Success <code>1</code> Error (validation failed, file not found, etc.)"},{"location":"AGENT_CONTEXT/#key-concepts-domain-vocabulary","title":"Key Concepts &amp; Domain Vocabulary","text":"Term Definition Bolt A unit of work (equivalent to a Sprint in Agile). Lives in <code>.geas/bolts/&lt;name&gt;/</code>. Intent Collection of preliminary documents (request, specs, plan) that define what to build. MRP Merge Request Package - post-code evidence proving implementation validity. Trinity Lock The cryptographic engine binding Identity, Integrity, and Audit. Seal Cryptographic lock operation that hashes content and records it in the ledger. Prove The process of running tests and generating a cryptographic manifest of the codebase. Active Context The currently selected bolt (tracked in <code>.geas/active_context.md</code>). Persona Behavioral template for agents (defined in <code>agents.yaml</code>). Identity Cryptographic identity with Ed25519 keys (stored in <code>identities.yaml</code>). Drift Unauthorized modification of sealed content (detected by hash mismatch). Geas A magical obligation/vow (the protocol's namesake metaphor). Manifest Cryptographic fingerprint (Merkle Tree) of source code at proof time. Workflow Governance policy defining required seals and role constraints. Note: Workflows are configurable via <code>workflow.yaml</code>, allowing GEAS to be used by solo agents or large teams."},{"location":"AGENT_CONTEXT/#file-templates-schemas","title":"File Templates &amp; Schemas","text":""},{"location":"AGENT_CONTEXT/#request-template-01_requestmd","title":"Request Template (<code>01_request.md</code>)","text":"<pre><code># Feature Request: {bolt_name}\n\n**Status:** PENDING\n\n## Instructions\nDescribe your feature request here. The Spec Writer will use this to generate the specifications.\n</code></pre>"},{"location":"AGENT_CONTEXT/#context-template-active_contextmd","title":"Context Template (<code>active_context.md</code>)","text":"<pre><code># Active Context\n\n**Current Bolt:** {bolt_name}\n**Path:** .geas/bolts/{bolt_name}\n**Started:** {timestamp}\n\n## Instructions for Agent\nYou are currently working on the Bolt listed above.\n1. Read the `01_request.md` in the target directory.\n2. If strictly following GEAS, do not edit code until `03_plan.md` is sealed.\n</code></pre>"},{"location":"AGENT_CONTEXT/#lock-file-schema-approvedlock","title":"Lock File Schema (<code>approved.lock</code>)","text":"<pre><code>req_hash: \"abc123...\"\nreq_sealed_at: \"2025-01-02T10:00:00\"\nspecs_hash: \"def456...\"\nspecs_sealed_at: \"2025-01-02T11:00:00\"\nplan_hash: \"ghi789...\"\nplan_sealed_at: \"2025-01-02T12:00:00\"\nmrp_hash: \"jkl012...\"\nmrp_sealed_at: \"2025-01-02T14:00:00\"\n</code></pre>"},{"location":"AGENT_CONTEXT/#agents-yaml-schema-agentsyaml","title":"Agents YAML Schema (<code>agents.yaml</code>)","text":"<pre><code>agents:\n  spec_writer:\n    role: \"Senior Product Owner\"\n    goal: \"Transform vague inputs into rigorous specifications.\"\n    backstory: |\n      You are a veteran Product Owner who adheres to INVEST...\n\n  developer:\n    role: \"Senior Implementation Specialist\"\n    goal: \"Execute the sealed plan into production-grade code.\"\n    backstory: |\n      You are a code craftsman. You value readability and type safety...\n</code></pre>"},{"location":"AGENT_CONTEXT/#models-yaml-schema-modelsyaml","title":"Models YAML Schema (<code>models.yaml</code>)","text":"<pre><code>models:\n  gpt4_turbo:\n    provider: \"openai\"\n    base_url: \"https://api.openai.com/v1\"\n    api_key: \"${OPENAI_API_KEY}\"\n    model_name: \"gpt-4-turbo\"\n\n  claude_sonnet:\n    provider: \"anthropic\"\n    base_url: \"https://api.anthropic.com\"\n    api_key: \"${ANTHROPIC_API_KEY}\"\n    model_name: \"claude-sonnet-4-20250514\"\n</code></pre>"},{"location":"AGENT_CONTEXT/#cicd-pipeline","title":"CI/CD Pipeline","text":""},{"location":"AGENT_CONTEXT/#github-actions-workflows","title":"GitHub Actions Workflows","text":"Workflow Trigger Purpose <code>ci.yml</code> Push/PR to <code>main</code> Run tests, linting, type checking <code>docs.yml</code> Push to <code>main</code> Build and deploy documentation <code>publish.yml</code> Release tag Publish to PyPI"},{"location":"AGENT_CONTEXT/#ci-steps","title":"CI Steps","text":"<pre><code>steps:\n  - uses: actions/checkout@v4\n  - name: Install uv\n  - name: Set up Python (3.12)\n  - name: Install dependencies (uv sync)\n  - name: Run Ruff Check\n  - name: Run Ruff Format Check\n  - name: Run MyPy\n  - name: Run Tests\n</code></pre>"},{"location":"AGENT_CONTEXT/#agent-personas","title":"Agent Personas","text":"<p>Defined in <code>.geas/config/agents.yaml</code>:</p> Persona Role Goal <code>spec_writer</code> Senior Product Owner Transform vague inputs into rigorous specifications using INVEST &amp; Gherkin <code>architect</code> Chief Domain Architect Design scalable file structures enforcing DOMA boundaries and SOLID/DRY principles <code>developer</code> Senior Implementation Specialist Execute sealed plans into production-grade, typed, tested code (TDD) <code>doc_writer</code> Lead Technical Writer Maintain documentation following Di\u00e1taxis framework <code>qa_engineer</code> QA Automation Engineer Validate compliance with specs and generate MRP"},{"location":"AGENT_CONTEXT/#agent-workflow-constraints","title":"Agent Workflow Constraints","text":"<ul> <li>spec_writer: Cannot start until <code>01_request.md</code> is sealed</li> <li>architect: Cannot start until <code>02_specs.md</code> is sealed</li> <li>developer: Cannot start until <code>03_plan.md</code> is sealed</li> <li>qa_engineer: Validates against sealed specs and generates MRP</li> </ul>"},{"location":"AGENT_CONTEXT/#current-development-status","title":"Current Development Status","text":""},{"location":"AGENT_CONTEXT/#implemented-v013","title":"Implemented (v0.1.3)","text":"<ul> <li>[x] <code>geas init</code> - Initialize GEAS directory structure</li> <li>[x] <code>geas new</code> - Create bolt workspace</li> <li>[x] <code>geas checkout</code> - Switch bolt context</li> <li>[x] <code>geas seal</code> - Hash and lock artifacts (req/specs/plan/mrp/intent)</li> <li>[x] <code>geas prove</code> - Test execution and Manifest generation</li> <li>[x] <code>geas status</code> - Display seal status</li> <li>[x] <code>geas verify</code> - Verify integrity and sequence</li> <li>[x] <code>geas approve</code> - Human approval of MRP</li> <li>[x] <code>geas delete</code> - Delete bolt</li> <li>[x] <code>geas archive</code> - Archive completed bolt</li> <li>[x] <code>geas agents</code> - List personas</li> <li>[x] <code>geas identity</code> - Manage cryptographic identities (add, list, show, revoke)</li> </ul>"},{"location":"AGENT_CONTEXT/#roadmap","title":"Roadmap","text":"Phase Objective Status Phase 1 Identity &amp; Keyring (<code>geas identity</code>) COMPLETE Phase 2 Intent Engine (<code>geas seal intent</code>) COMPLETE Phase 3 Proof Engine (<code>geas prove</code>, <code>geas approve</code>) COMPLETE Phase 4 Verification Engine (workflow-based validation) In Progress Phase 5 Lifecycle Management (enhanced <code>archive</code>/<code>delete</code>) In Progress Phase 6 CI/CD Integration (GitHub Actions/GitLab CI templates) Planned"},{"location":"AGENT_CONTEXT/#critical-rules-for-agents","title":"Critical Rules for Agents","text":""},{"location":"AGENT_CONTEXT/#before-starting-work","title":"Before Starting Work","text":"<ol> <li>Read <code>.geas/active_context.md</code> to identify current bolt</li> <li>Check the bolt's <code>approved.lock</code> for sealed artifacts</li> <li>Follow the seal sequence: <code>req</code> \u2192 <code>specs</code> \u2192 <code>plan</code> \u2192 code \u2192 <code>mrp</code></li> <li>Do NOT edit code until <code>03_plan.md</code> is sealed (if strictly following GEAS)</li> </ol>"},{"location":"AGENT_CONTEXT/#during-development","title":"During Development","text":"<ul> <li>Source code location: <code>src/geas_ai/</code></li> <li>Tests location: <code>tests/</code></li> <li>Run tests: <code>uv run pytest</code></li> <li>Run linting: <code>uv run ruff check .</code></li> <li>Type check: <code>uv run mypy src</code></li> </ul>"},{"location":"AGENT_CONTEXT/#key-files-to-understand","title":"Key Files to Understand","text":"File Purpose <code>src/geas_ai/main.py</code> CLI entry point, command registration <code>src/geas_ai/utils.py</code> Shared utilities (hashing, path resolution) <code>src/geas_ai/core/content.py</code> Templates and default YAML content <code>src/geas_ai/commands/*.py</code> Individual CLI command implementations"},{"location":"AGENT_CONTEXT/#error-patterns","title":"Error Patterns","text":"<ul> <li>Use <code>typer.Exit(code=1)</code> for controlled failures</li> <li>Use <code>console.print(\"[bold red]Error:[/bold red] ...\")</code> for error messages</li> <li>Validate GEAS initialization with <code>utils.ensure_geas_root()</code></li> <li>Validate slugs with <code>utils.validate_slug(name)</code></li> </ul>"},{"location":"AGENT_CONTEXT/#code-quality-checklist","title":"Code Quality Checklist","text":"<p>Before submitting any code:</p> <ul> <li>[ ] All functions have type hints</li> <li>[ ] All public functions have Google-style docstrings</li> <li>[ ] Tests cover happy paths, edge cases, and failure modes</li> <li>[ ] <code>uv run pytest</code> passes</li> <li>[ ] <code>uv run ruff check .</code> passes</li> <li>[ ] <code>uv run mypy src</code> passes</li> <li>[ ] No repeated logic (DRY principle applied)</li> </ul>"},{"location":"AGENT_CONTEXT/#quick-reference-card","title":"Quick Reference Card","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                     GEAS-AI Quick Reference                      \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Package: geas-ai          \u2502 Python: &gt;=3.10                      \u2502\n\u2502 CLI: geas                 \u2502 Manager: uv                         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 GEAS COMMANDS                                                    \u2502\n\u2502   geas init               \u2502 Initialize GEAS                     \u2502\n\u2502   geas new &lt;name&gt;         \u2502 Create bolt                         \u2502\n\u2502   geas seal &lt;target&gt;      \u2502 Seal artifact (req/specs/plan/mrp)  \u2502\n\u2502   geas prove              \u2502 Run tests &amp; generate manifest       \u2502\n\u2502   geas status             \u2502 Show status                         \u2502\n\u2502   geas verify             \u2502 Verify integrity                    \u2502\n\u2502   geas approve            \u2502 Approve sealed MRP                  \u2502\n\u2502   geas checkout &lt;name&gt;    \u2502 Switch context                      \u2502\n\u2502   geas archive &lt;name&gt;     \u2502 Archive bolt                        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 DEV COMMANDS                                                     \u2502\n\u2502   uv sync                 \u2502 Install dependencies                \u2502\n\u2502   uv run pytest           \u2502 Run tests                           \u2502\n\u2502   uv run ruff check .     \u2502 Lint code                          \u2502\n\u2502   uv run mypy src         \u2502 Type check                          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 SEAL SEQUENCE: req \u2192 specs \u2192 plan \u2192 [code] \u2192 mrp                 \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 PATHS                                                            \u2502\n\u2502   .geas/active_context.md \u2502 Current bolt pointer                \u2502\n\u2502   .geas/bolts/&lt;name&gt;/     \u2502 Bolt workspace                      \u2502\n\u2502   src/geas_ai/            \u2502 Source code                         \u2502\n\u2502   tests/                  \u2502 Test suite                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>This document should be read by any AI agent before contributing to the GEAS-AI repository.</p>"},{"location":"TRINITY_LOCK/","title":"Technical Specification: The Trinity Lock Protocol","text":"<p>Version: 3.1</p>"},{"location":"TRINITY_LOCK/#overview","title":"Overview","text":"<p>The Trinity Lock is the cryptographic engine behind GEAS. It replaces simple file hashing with a multi-layered security model that provides non-repudiable proof of who authorized what, and when.</p>"},{"location":"TRINITY_LOCK/#design-principles","title":"Design Principles","text":"<ol> <li>Repository Native \u2014 Lives entirely in folders; no external database.</li> <li>Git Independent \u2014 Validates without relying on <code>.git</code> history.</li> <li>Agent-First \u2014 Designed for multi-agent environments.</li> <li>Workflow Agnostic \u2014 Configurable governance policies.</li> <li>Cryptographically Secured \u2014 Ed25519 signatures for non-repudiation.</li> </ol>"},{"location":"TRINITY_LOCK/#why-cryptographic-signing","title":"Why Cryptographic Signing?","text":"<p>Git authorship (<code>git config user.name</code>) is trivially spoofable. Anyone with repo access can claim to be any author. GEAS uses Ed25519 signatures to prove:</p> <ul> <li>Non-repudiation: The holder of the private key signed this event.</li> <li>Tamper evidence: If <code>lock.json</code> is manually edited, signatures won't verify.</li> <li>Independent verification: The chain can be verified without trusting Git history.</li> </ul>"},{"location":"TRINITY_LOCK/#the-scope-of-locking","title":"The Scope of Locking","text":"<p>The Trinity Lock applies strictly to Governance Artifacts. It does NOT lock source code files, allowing development to remain fluid.</p> Layer Content Lock State Purpose INTENT <code>01_request.md</code>, <code>02_specs.md</code>, <code>03_plan.md</code>, custom docs Immutable Defines what must be built. Sealed before coding starts. CODE <code>src/</code>, <code>tests/</code> Mutable The implementation. Evolves freely during the Bolt lifecycle. MRP <code>mrp/summary.md</code>, <code>mrp/tests.log</code>, <code>mrp/manifest.json</code> Immutable The evidence. Sealed after tests pass."},{"location":"TRINITY_LOCK/#the-three-pillars","title":"The Three Pillars","text":"<p>The Trinity Lock is defined by the convergence of three cryptographic proofs:</p> Pillar Concept Implementation Identity Non-Repudiation Ed25519 Signatures (SSH format). Every seal must be signed by a registered actor. Integrity Physical State SHA-256 hashes. A map of file paths to their content hashes. Audit Traceability Hash Chain. Each event references the hash of the previous event, forming a local ledger."},{"location":"TRINITY_LOCK/#configuration-architecture","title":"Configuration Architecture","text":"<p>GEAS uses three configuration files, logically coupled by reference:</p> <pre><code>.geas/config/\n\u251c\u2500\u2500 agents.yaml        # Persona definitions (behavior)\n\u251c\u2500\u2500 models.yaml        # Provider configs (runtime)\n\u2514\u2500\u2500 identities.yaml    # Cryptographic identities (security)\n</code></pre>"},{"location":"TRINITY_LOCK/#1-agents-configuration-agentsyaml","title":"1. Agents Configuration (<code>agents.yaml</code>)","text":"<p>Defines personas\u2014the behavioral templates for agents.</p> <pre><code># .geas/config/agents.yaml\n\nagents:\n  spec_writer:\n    role: \"Senior Product Owner\"\n    goal: \"Transform vague inputs into rigorous, unambiguous functional specifications.\"\n    backstory: |\n      You are a veteran Product Owner who adheres to the INVEST mnemonic...\n\n  developer:\n    role: \"Senior Implementation Specialist\"\n    goal: \"Execute the sealed plan into production-grade, typed, and tested code.\"\n    backstory: |\n      You are a code craftsman. You value readability and type safety...\n\n  qa_engineer:\n    role: \"QA Automation Engineer\"\n    goal: \"Validate compliance with specs and generate the Merge Readiness Pack (MRP).\"\n    backstory: |\n      You trust nothing. You verify that the produced code strictly satisfies...\n</code></pre>"},{"location":"TRINITY_LOCK/#2-models-configuration-modelsyaml","title":"2. Models Configuration (<code>models.yaml</code>)","text":"<p>Defines providers\u2014the LLM backends that power agents.</p> <pre><code># .geas/config/models.yaml\n\nmodels:\n  gpt4_turbo:\n    provider: \"openai\"\n    base_url: \"https://api.openai.com/v1\"\n    api_key: \"${OPENAI_API_KEY}\"\n    model_name: \"gpt-4-turbo\"\n\n  claude_sonnet:\n    provider: \"anthropic\"\n    base_url: \"https://api.anthropic.com\"\n    api_key: \"${ANTHROPIC_API_KEY}\"\n    model_name: \"claude-sonnet-4-20250514\"\n\n  local_llama:\n    provider: \"ollama\"\n    base_url: \"http://localhost:11434/v1\"\n    model_name: \"llama3:7b\"\n</code></pre>"},{"location":"TRINITY_LOCK/#3-identities-configuration-identitiesyaml","title":"3. Identities Configuration (<code>identities.yaml</code>)","text":"<p>Defines cryptographic identities\u2014the keys used for signing seals.</p> <pre><code># .geas/config/identities.yaml\n\nidentities:\n  # Humans\n  - name: \"arch-lead\"\n    role: \"human\"\n    active_key: \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5... arch-lead@company.com\"\n    revoked_keys: []\n\n  # Agent instances (references persona + model)\n  - name: \"claude-developer\"\n    role: \"agent\"\n    persona: \"developer\"           # References agents.yaml\n    model: \"claude_sonnet\"         # References models.yaml\n    active_key: \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5... claude-developer@geas\"\n    revoked_keys: []\n\n  - name: \"gpt-qa\"\n    role: \"agent\"\n    persona: \"qa_engineer\"\n    model: \"gpt4_turbo\"\n    active_key: \"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5... gpt-qa@geas\"\n    revoked_keys: []\n</code></pre> <p>Key Resolution Logic:</p> <ol> <li>Check environment variable: <code>GEAS_KEY_{NAME}</code> (for CI/agents).</li> <li>Check local keyring: <code>~/.geas/keys/{name}.key</code> (for humans).</li> <li>If not found \u2192 Abort with \"Identity not found\" error.</li> </ol>"},{"location":"TRINITY_LOCK/#4-workflow-configuration-workflowyaml","title":"4. Workflow Configuration (<code>workflow.yaml</code>)","text":"<p>Defines the governance policy for the repository.</p> <pre><code># .geas/config/workflow.yaml\n\nworkflow:\n  name: \"standard\"\n  version: \"1.0\"\n\n  intent_documents:\n    required:\n      - \"01_request.md\"\n      - \"02_specs.md\"\n    optional:\n      - \"03_plan.md\"\n      - \"04_architecture.md\"\n\n  stages:\n    - id: \"intent\"\n      action: \"SEAL_INTENT\"\n      required_role: \"human\"\n      description: \"Human must seal all Intent documents before coding begins.\"\n\n    - id: \"proof\"\n      action: \"SEAL_MRP\"\n      required_role: \"agent\"\n      prerequisite: \"intent\"\n      description: \"Agent seals MRP after tests pass.\"\n\n    - id: \"approval\"\n      action: \"APPROVE\"\n      required_role: \"human\"\n      prerequisite: \"proof\"\n      description: \"Human approves the MRP for merge.\"\n\n  test_command: \"pytest -v\"\n  test_timeout: 300\n</code></pre>"},{"location":"TRINITY_LOCK/#data-structures","title":"Data Structures","text":""},{"location":"TRINITY_LOCK/#the-lock-ledger-lockjson","title":"The Lock Ledger (<code>lock.json</code>)","text":"<p>Every Bolt folder contains a <code>lock.json</code> file. This is the append-only ledger of all governance events.</p> <pre><code>{\n  \"version\": \"3.1\",\n  \"bolt_id\": \"feature-login\",\n  \"created_at\": \"2025-01-02T10:00:00Z\",\n  \"head_hash\": \"sha256:abc123...\",\n  \"events\": [\n    { /* Event 1: SEAL_INTENT */ },\n    { /* Event 2: SEAL_MRP */ },\n    { /* Event 3: APPROVE */ }\n  ]\n}\n</code></pre>"},{"location":"TRINITY_LOCK/#event-schema","title":"Event Schema","text":"<p>Each event in the ledger follows this structure:</p> <pre><code>{\n  \"sequence\": 1,\n  \"timestamp\": \"2025-01-02T12:05:00Z\",\n  \"action\": \"SEAL_INTENT\",\n\n  \"payload\": {\n    \"files\": {\n      \"01_request.md\": \"sha256:a1b2c3...\",\n      \"02_specs.md\": \"sha256:d4e5f6...\",\n      \"03_plan.md\": \"sha256:g7h8i9...\"\n    },\n    \"context\": \"Approved by Architecture Board\"\n  },\n\n  \"prev_hash\": \"sha256:000000...\",\n\n  \"identity\": {\n    \"signer_id\": \"arch-lead\",\n    \"public_key\": \"ssh-ed25519 AAAAC3...\",\n    \"signature\": \"base64_signature_of_canonical_payload\"\n  },\n\n  \"event_hash\": \"sha256:abc123...\"\n}\n</code></pre> <p>Event Types:</p> Action Layer Description <code>SEAL_INTENT</code> INTENT Seals the Intent documents. <code>SEAL_MRP</code> MRP Seals the Merge Request Package. <code>APPROVE</code> MRP Human approval of sealed MRP."},{"location":"TRINITY_LOCK/#the-mrp-manifest-mrpmanifestjson","title":"The MRP Manifest (<code>mrp/manifest.json</code>)","text":"<p>Generated during <code>geas prove</code>. Captures the exact state of source code at proof time.</p> <pre><code>{\n  \"generated_at\": \"2025-01-02T14:30:00Z\",\n  \"bolt_id\": \"feature-login\",\n  \"scope\": [\"src/\", \"tests/\"],\n\n  \"files\": {\n    \"src/auth/login.py\": \"sha256:...\",\n    \"src/auth/oauth.py\": \"sha256:...\",\n    \"tests/test_login.py\": \"sha256:...\"\n  },\n\n  \"root_hash\": \"sha256:...\",\n\n  \"test_result\": {\n    \"passed\": true,\n    \"exit_code\": 0,\n    \"duration_seconds\": 12.5\n  }\n}\n</code></pre>"},{"location":"TRINITY_LOCK/#algorithms-procedures","title":"Algorithms &amp; Procedures","text":""},{"location":"TRINITY_LOCK/#1-sealing-intent-geas-seal-intent","title":"1. Sealing Intent (<code>geas seal intent</code>)","text":"<p>Goal: Freeze the preliminary documents with cryptographic proof.</p> <p>Procedure:</p> <ol> <li>Identify Target Files: Read <code>workflow.yaml</code> to determine which documents are required/optional.</li> <li>Validate Presence: Ensure all required Intent documents exist.</li> <li>Calculate Hashes: SHA-256 hash of each file's content.</li> <li>Resolve Identity: Load the signer's private key (must be <code>role: human</code>).</li> <li>Construct Event:</li> <li><code>action</code>: <code>SEAL_INTENT</code></li> <li><code>payload.files</code>: Map of filename \u2192 hash</li> <li><code>prev_hash</code>: Hash of the last event (or <code>null</code> for genesis)</li> <li>Sign Event: Sign the canonical JSON of the event payload using Ed25519.</li> <li>Append to Ledger: Add the event to <code>lock.json</code>.</li> <li>Update Head Hash: Set <code>head_hash</code> to the new event's hash.</li> </ol>"},{"location":"TRINITY_LOCK/#2-proving-work-geas-prove","title":"2. Proving Work (<code>geas prove</code>)","text":"<p>Goal: Run tests, snapshot code, generate MRP, and seal it.</p> <p>Procedure:</p> <ol> <li>Validate State: Ensure Intent is already sealed.</li> <li>Run Tests: Execute the configured test command. Capture stdout/stderr.</li> <li>Check Result: If tests fail, abort with error.</li> <li>Generate Manifest:</li> <li>Walk <code>src/</code> and <code>tests/</code> directories.</li> <li>Respect <code>.gitignore</code> rules (use <code>pathspec</code> library).</li> <li>Hash each file (SHA-256).</li> <li>Sort keys alphabetically for deterministic output.</li> <li>Calculate Merkle root hash.</li> <li>Write MRP Artifacts:</li> <li><code>mrp/manifest.json</code> \u2014 The code snapshot.</li> <li><code>mrp/tests.log</code> \u2014 Captured test output.</li> <li><code>mrp/summary.md</code> \u2014 Human-readable summary.</li> <li>Seal MRP:</li> <li>Hash the MRP files.</li> <li>Resolve agent identity.</li> <li>Construct and sign <code>SEAL_MRP</code> event.</li> <li>Append to ledger.</li> </ol>"},{"location":"TRINITY_LOCK/#3-verifying-a-bolt-geas-verify","title":"3. Verifying a Bolt (<code>geas verify</code>)","text":"<p>Goal: Validate the Bolt against the configured workflow.</p> <p>Procedure:</p> <ol> <li>Load Workflow: Parse <code>.geas/config/workflow.yaml</code>.</li> <li>Load Ledger: Parse the Bolt's <code>lock.json</code>.</li> <li>Validate Chain Integrity:</li> <li>For each event, verify <code>prev_hash</code> matches the hash of the previous event.</li> <li>For the first event, verify <code>prev_hash</code> is <code>null</code>.</li> <li>Validate Signatures:</li> <li>For each event, resolve the signer's public key from <code>identities.yaml</code>.</li> <li>Verify the signature matches the canonical payload.</li> <li>Ensure the key is not in <code>revoked_keys</code>.</li> <li>Validate Workflow Compliance:</li> <li>Check that all required stages are present.</li> <li>Check that prerequisites are satisfied (e.g., <code>proof</code> requires <code>intent</code>).</li> <li>Check that role requirements are met (e.g., <code>intent</code> sealed by <code>human</code>).</li> <li>Validate Content Integrity (optional, if files still exist):</li> <li>Re-hash Intent files and compare against sealed hashes.</li> <li>Re-hash MRP files and compare against sealed hashes.</li> <li>Return Result: PASS with details, or FAIL with specific violation.</li> </ol>"},{"location":"TRINITY_LOCK/#cryptographic-details","title":"Cryptographic Details","text":""},{"location":"TRINITY_LOCK/#key-format","title":"Key Format","text":"<p>GEAS uses SSH-format Ed25519 keys for compatibility with existing tooling.</p> <p>Generate a new key:</p> <pre><code>ssh-keygen -t ed25519 -f ~/.geas/keys/my-identity.key -N \"\" -C \"my-identity@geas\"\n</code></pre> <p>Key storage:</p> Actor Type Private Key Location Public Key Location Human <code>~/.geas/keys/{name}.key</code> <code>.geas/config/identities.yaml</code> Agent (CI) <code>GEAS_KEY_{NAME}</code> env var <code>.geas/config/identities.yaml</code>"},{"location":"TRINITY_LOCK/#signature-algorithm","title":"Signature Algorithm","text":"<ol> <li>Canonicalize Payload: Sort JSON keys, no whitespace, UTF-8 encoding.</li> <li>Sign: Ed25519 signature of the canonical bytes.</li> <li>Encode: Base64-encode the signature for storage.</li> </ol>"},{"location":"TRINITY_LOCK/#hash-chain","title":"Hash Chain","text":"<p>Each event's <code>event_hash</code> is calculated as:</p> <pre><code>event_hash = SHA-256(canonical_json(event_without_event_hash))\n</code></pre> <p>The next event's <code>prev_hash</code> must equal the previous event's <code>event_hash</code>.</p>"},{"location":"TRINITY_LOCK/#implementation-roadmap","title":"Implementation Roadmap","text":""},{"location":"TRINITY_LOCK/#phase-1-identity-keyring","title":"Phase 1: Identity &amp; Keyring","text":"<p>Objective: <code>geas init</code> and <code>geas identity</code></p> <p>Deliverables:</p> <ul> <li>SSH-format Ed25519 key generation.</li> <li><code>identities.yaml</code> schema and parser.</li> <li>Key resolution logic (env var \u2192 local keyring).</li> <li>Sign/verify utility functions.</li> </ul> <p>Libraries: <code>cryptography</code>, <code>paramiko</code> (for SSH key parsing).</p>"},{"location":"TRINITY_LOCK/#phase-2-intent-engine","title":"Phase 2: Intent Engine","text":"<p>Objective: <code>geas seal intent</code></p> <p>Deliverables:</p> <ul> <li>Workflow configuration parser.</li> <li>File hashing with SHA-256.</li> <li>Ledger append logic with hash chain.</li> <li>Event signing with Ed25519.</li> </ul> <p>Libraries: <code>hashlib</code>, <code>pydantic</code> (schema validation).</p>"},{"location":"TRINITY_LOCK/#phase-3-proof-engine-mrp","title":"Phase 3: Proof Engine (MRP)","text":"<p>Objective: <code>geas prove</code></p> <p>Deliverables:</p> <ul> <li>Test runner integration (<code>subprocess</code>).</li> <li>Directory walker with <code>.gitignore</code> support.</li> <li>Manifest generator (deterministic JSON).</li> <li>MRP folder generation.</li> <li><code>SEAL_MRP</code> event creation with agent signature.</li> </ul> <p>Libraries: <code>pathspec</code> (gitignore parsing), <code>subprocess</code>.</p>"},{"location":"TRINITY_LOCK/#phase-4-verification-engine","title":"Phase 4: Verification Engine","text":"<p>Objective: <code>geas verify</code></p> <p>Deliverables:</p> <ul> <li>Chain integrity validator.</li> <li>Signature verification.</li> <li>Workflow compliance checker.</li> <li>Content integrity verification.</li> </ul>"},{"location":"TRINITY_LOCK/#phase-5-lifecycle-management","title":"Phase 5: Lifecycle Management","text":"<p>Objective: <code>geas archive</code>, <code>geas delete</code></p> <p>Deliverables:</p> <ul> <li>Bolt archival (move to <code>.geas/archive/</code>).</li> <li>Bolt deletion (with confirmation).</li> </ul>"},{"location":"TRINITY_LOCK/#phase-6-cicd-integration","title":"Phase 6: CI/CD Integration","text":"<p>Objective: Enterprise automation</p> <p>Deliverables:</p> <ul> <li>GitHub Actions workflow templates.</li> <li>GitLab CI templates.</li> <li>Documentation for key injection in CI.</li> <li>PR status checks (block merge without valid MRP).</li> </ul>"},{"location":"TRINITY_LOCK/#technology-stack","title":"Technology Stack","text":"Component Library Rationale Cryptography <code>cryptography</code> Industry-standard, audited. SSH Key Parsing <code>paramiko</code> or <code>cryptography</code> Native SSH format support. Schema Validation <code>pydantic</code> Strict typing, excellent errors. Gitignore Parsing <code>pathspec</code> Correct <code>.gitignore</code> semantics. CLI Framework <code>typer</code> Modern, type-hinted CLI. YAML Parsing <code>ruamel.yaml</code> Preserves comments and formatting."},{"location":"TRINITY_LOCK/#appendix-example-workflows","title":"Appendix: Example Workflows","text":""},{"location":"TRINITY_LOCK/#minimal-workflow-solo-developer","title":"Minimal Workflow (Solo Developer)","text":"<pre><code>workflow:\n  name: \"minimal\"\n  intent_documents:\n    required: [\"02_specs.md\"]\n  stages:\n    - id: \"intent\"\n      action: \"SEAL_INTENT\"\n      required_role: \"human\"\n    - id: \"proof\"\n      action: \"SEAL_MRP\"\n      required_role: \"agent\"\n      prerequisite: \"intent\"\n</code></pre>"},{"location":"TRINITY_LOCK/#enterprise-workflow-multi-agent-team","title":"Enterprise Workflow (Multi-Agent Team)","text":"<pre><code>workflow:\n  name: \"enterprise\"\n  intent_documents:\n    required: [\"01_request.md\", \"02_specs.md\", \"03_plan.md\"]\n    optional: [\"04_architecture.md\", \"05_research.md\"]\n  stages:\n    - id: \"request\"\n      action: \"SEAL_INTENT\"\n      files: [\"01_request.md\"]\n      required_role: \"human\"\n    - id: \"specs\"\n      action: \"SEAL_INTENT\"\n      files: [\"02_specs.md\", \"03_plan.md\"]\n      required_role: \"human\"\n      prerequisite: \"request\"\n    - id: \"proof\"\n      action: \"SEAL_MRP\"\n      required_role: \"agent\"\n      prerequisite: \"specs\"\n    - id: \"review\"\n      action: \"APPROVE\"\n      required_role: \"human\"\n      prerequisite: \"proof\"\n</code></pre>"},{"location":"TRINITY_LOCK/#conclusion","title":"Conclusion","text":"<p>The Trinity Lock Protocol provides a rigorous, flexible, and auditable governance layer for agentic software development. By binding Identity, Integrity, and Audit into a cryptographic chain, GEAS ensures that every piece of generated code can be traced back to its authorized intent\u2014with proof that cannot be forged or repudiated.</p>"},{"location":"WHITE_PAPER/","title":"GEAS: Governance Enforcement for Agent Systems","text":"<p>Protocol for the \"Software Engineering 3.0\" Era</p> <p>Version: 3.1</p>"},{"location":"WHITE_PAPER/#executive-summary","title":"Executive Summary","text":"<p>GEAS (pronounced gesh) is a repository-native governance protocol designed to solve the \"Day 2\" problem of AI-driven development: Trust.</p> <p>As software engineering shifts from Human-Authored to Agent-Generated, the bottleneck moves from velocity to verification. Organizations face a new risk: \"Agent Drift\"\u2014autonomous models deviating from intent, hallucinating features, or introducing subtle bugs that bypass traditional review.</p> <p>GEAS solves this by treating Agent instructions as a Binding Vow (a Geas). It enforces a strict \"Filesystem Sovereignty\" model where:</p> <ol> <li>Intent is cryptographically sealed before work begins.</li> <li>Code remains freely mutable during development.</li> <li>Evidence (the MRP) is cryptographically sealed before code is merged.</li> </ol>"},{"location":"WHITE_PAPER/#why-not-just-git","title":"Why Not Just Git?","text":"<p>Git provides versioning and history, but Git authorship is trivially spoofable\u2014anyone with repo access can set any author string. GEAS adds cryptographic non-repudiation:</p> Capability Git GEAS Track changes \u2705 \u2705 Author attribution \u26a0\ufe0f Spoofable \u2705 Ed25519 signatures Intent-to-code binding \u274c \u2705 Sealed specs \u2192 manifest Prove tests passed for code version X \u274c \u2705 MRP with test logs + code snapshot Role-based workflow enforcement \u274c \u2705 Configurable stages"},{"location":"WHITE_PAPER/#the-core-philosophy","title":"The Core Philosophy","text":""},{"location":"WHITE_PAPER/#the-metaphor-the-geas","title":"The Metaphor: The Geas","text":"<p>In mythology, a Geas is a magical obligation. If the hero breaks the vow, they lose their power.</p> <p>In our protocol:</p> Element Meaning The Hero The AI Agent(s) The Vow The Intent Documents (requirements, specs, architecture, plan) The Power The ability to merge code"},{"location":"WHITE_PAPER/#the-day-2-reality","title":"The \"Day 2\" Reality","text":"<p>Current agentic tools focus on code generation. GEAS focuses on the Chain of Custody:</p> <ul> <li>Identity: Who authorized this feature? (Cryptographically proven)</li> <li>Integrity: Have the Intent documents changed during development?</li> <li>Audit: Can we prove the tests passed for this specific version of the code?</li> </ul>"},{"location":"WHITE_PAPER/#the-architecture-steering-engine","title":"The Architecture: \"Steering &amp; Engine\"","text":"<p>GEAS is not a SaaS platform. It is a local protocol defined by a hidden directory structure (<code>.geas/</code>) that lives alongside your code.</p> <pre><code>.geas/\n\u251c\u2500\u2500 config/\n\u2502   \u251c\u2500\u2500 agents.yaml        # Agent personas (role, goal, backstory)\n\u2502   \u251c\u2500\u2500 models.yaml        # Model providers (API keys, endpoints)\n\u2502   \u251c\u2500\u2500 identities.yaml    # Cryptographic identities (public keys)\n\u2502   \u2514\u2500\u2500 workflow.yaml      # Governance rules (seal sequence, roles)\n\u2514\u2500\u2500 bolts/\n    \u2514\u2500\u2500 feature-login/     # One Bolt = One unit of work\n        \u251c\u2500\u2500 01_request.md\n        \u251c\u2500\u2500 02_specs.md\n        \u251c\u2500\u2500 03_plan.md\n        \u251c\u2500\u2500 lock.json      # The cryptographic ledger\n        \u2514\u2500\u2500 mrp/           # Merge Request Package\n</code></pre>"},{"location":"WHITE_PAPER/#the-three-configuration-files","title":"The Three Configuration Files","text":"File Purpose Contents <code>agents.yaml</code> Persona definitions Role, goal, backstory for each agent type <code>models.yaml</code> Provider configs API endpoints, model names, credentials <code>identities.yaml</code> Cryptographic identities Public keys for humans and agents <p>These files are logically coupled by reference:</p> <ul> <li>An identity in <code>identities.yaml</code> references a persona from <code>agents.yaml</code></li> <li>An identity may be backed by a model from <code>models.yaml</code></li> </ul>"},{"location":"WHITE_PAPER/#the-two-components","title":"The Two Components","text":"Component Role Example The Steering (Protocol) The <code>geas</code> CLI manages Bolt lifecycles and acts as the notary. <code>geas new</code>, <code>geas seal</code>, <code>geas prove</code> The Engine (Agent) Your existing AI tool (Claude, GPT, local LLM) acts as the runtime. It reads GEAS state to understand its boundaries. Cursor, Windsurf, Aider, custom agents"},{"location":"WHITE_PAPER/#core-concepts","title":"Core Concepts","text":""},{"location":"WHITE_PAPER/#the-bolt","title":"The Bolt","text":"<p>A Bolt is the fundamental unit of work in GEAS\u2014equivalent to a Sprint in Agile methodology.</p> <p>Each Bolt:</p> <ul> <li>Represents a discrete feature, fix, or task.</li> <li>Lives in its own folder under <code>.geas/bolts/&lt;bolt-name&gt;/</code>.</li> <li>Contains all governance artifacts: Intent documents, lock ledger, and MRP.</li> <li>Has a defined lifecycle: <code>active</code> \u2192 <code>sealed</code> \u2192 <code>archived</code>.</li> </ul>"},{"location":"WHITE_PAPER/#the-intent","title":"The Intent","text":"<p>Intent is the collection of all preliminary documents that provide context for building code:</p> <ul> <li><code>01_request.md</code> \u2014 The business request or user story.</li> <li><code>02_specs.md</code> \u2014 Functional and technical specifications.</li> <li><code>03_plan.md</code> \u2014 Implementation plan and architecture notes.</li> <li>(Extensible) \u2014 Research notes, design decisions, API contracts, etc.</li> </ul> <p>The Intent is abstractable by design. GEAS does not dictate which documents you must have\u2014it enforces that whatever documents you define as Intent are sealed and immutable before code generation begins.</p>"},{"location":"WHITE_PAPER/#the-mrp-merge-request-package","title":"The MRP (Merge Request Package)","text":"<p>The MRP is a post-code evidence package proving the validity of the implementation:</p> <ul> <li><code>mrp/summary.md</code> \u2014 Human-readable summary of what was built.</li> <li><code>mrp/tests.log</code> \u2014 Captured test execution output.</li> <li><code>mrp/manifest.json</code> \u2014 Cryptographic fingerprint (Merkle Tree) of the source code at proof time.</li> </ul> <p>The MRP is sealed after tests pass, creating permanent evidence that \"Code Version X passed Test Suite Y.\"</p>"},{"location":"WHITE_PAPER/#the-lifecycle-of-a-bolt","title":"The Lifecycle of a Bolt","text":""},{"location":"WHITE_PAPER/#phase-i-the-ritual-intent","title":"Phase I: The Ritual (Intent)","text":"<ol> <li><code>geas new &lt;feature&gt;</code> \u2014 Creates the Bolt workspace.</li> <li>Drafting \u2014 Human Architect (or Agent with Human approval) writes the Intent documents.</li> <li><code>geas seal intent</code> \u2014 Human signs and seals the Intent.</li> <li>Effect: A cryptographic hash of these documents is recorded in <code>lock.json</code>, signed with the human's private key. The Agent cannot rewrite its own instructions without detection.</li> </ol>"},{"location":"WHITE_PAPER/#phase-ii-the-execution-code","title":"Phase II: The Execution (Code)","text":"<ol> <li>Coding \u2014 The Agent reads the sealed Intent and generates/modifies implementation files in <code>src/</code>.</li> <li>Mutability \u2014 Source code remains freely mutable. The Agent can iterate, refactor, and fix bugs without breaking any locks.</li> </ol>"},{"location":"WHITE_PAPER/#phase-iii-the-judgment-proof","title":"Phase III: The Judgment (Proof)","text":"<ol> <li><code>geas prove</code> \u2014 The System:</li> <li>Runs the test suite (e.g., <code>pytest</code>).</li> <li>Snapshots the code (generates <code>manifest.json</code>).</li> <li>Generates the MRP artifacts.</li> <li>Seals the MRP with the Agent's signature.</li> <li>Effect \u2014 Cryptographic evidence is created. The Bolt is ready for merge review.</li> </ol>"},{"location":"WHITE_PAPER/#phase-iv-the-merge","title":"Phase IV: The Merge","text":"<ol> <li>Human Review \u2014 A Human Approver reviews the sealed MRP.</li> <li><code>geas verify</code> \u2014 Validates the Bolt against the configured workflow (all required seals present, signatures valid, chain unbroken).</li> <li>Merge \u2014 If verification passes, the code can be merged. PRs without a valid MRP are rejected.</li> </ol>"},{"location":"WHITE_PAPER/#the-trinity-lock","title":"The Trinity Lock","text":"<p>The Trinity Lock is the cryptographic engine behind GEAS. Unlike a simple file hash, it binds three distinct pillars into a single cryptographic record:</p> Pillar Concept Implementation Physical Integrity \"The content hasn't changed.\" SHA-256 hashes / Merkle Trees Identity \"We know who authorized this.\" Ed25519 Signatures (SSH format) Audit History \"We know the sequence of events.\" Hash-Chain Ledger <p>Every seal operation appends an event to the Bolt's <code>lock.json</code>, where each event:</p> <ul> <li>Is cryptographically signed by the actor (human or agent)</li> <li>References the hash of the previous event (forming an immutable chain)</li> <li>Contains the hashes of the sealed files</li> </ul> <p>This creates tamper-evident, non-repudiable proof of the governance process.</p>"},{"location":"WHITE_PAPER/#target-environment-multi-agent-enterprise","title":"Target Environment: Multi-Agent Enterprise","text":"<p>GEAS is designed for professional agentic environments where:</p> <ul> <li>Multiple AI agents collaborate on the same repository.</li> <li>Agents have different personas (spec_writer, architect, developer, qa_engineer).</li> <li>Human oversight is required for critical approvals.</li> <li>Enterprise compliance demands auditable, cryptographically-secured chains of custody.</li> </ul>"},{"location":"WHITE_PAPER/#cicd-integration","title":"CI/CD Integration","text":"<p>GEAS follows a proactive MRP model:</p> <ol> <li>Agents generate code and run <code>geas prove</code> locally or in CI.</li> <li>CI prepares the MRP and pushes it for Human review.</li> <li>Merge is blocked until an approved MRP exists.</li> <li>Reviewers run <code>geas verify</code> to validate the full chain before approving the PR.</li> </ol> <p>This ensures that no code enters the main branch without cryptographic proof of:</p> <ul> <li>What was requested (sealed Intent).</li> <li>What was built (sealed MRP with code manifest).</li> <li>Who authorized each step (signatures).</li> </ul>"},{"location":"WHITE_PAPER/#the-workflow-configuration","title":"The Workflow Configuration","text":"<p>GEAS is workflow-agnostic. Projects define their own governance policies in <code>.geas/config/workflow.yaml</code>:</p> <pre><code># Example: Standard multi-agent workflow\nworkflow:\n  name: \"standard\"\n\n  intent_documents:\n    required: [\"01_request.md\", \"02_specs.md\"]\n    optional: [\"03_plan.md\", \"04_architecture.md\"]\n\n  stages:\n    - id: \"intent\"\n      action: \"SEAL_INTENT\"\n      required_role: \"human\"\n\n    - id: \"proof\"\n      action: \"SEAL_MRP\"\n      required_role: \"agent\"\n      prerequisite: \"intent\"\n\n    - id: \"approval\"\n      action: \"APPROVE\"\n      required_role: \"human\"\n      prerequisite: \"proof\"\n</code></pre> <p>The <code>geas verify</code> command validates the current Bolt state against this workflow definition.</p>"},{"location":"WHITE_PAPER/#command-summary","title":"Command Summary","text":"Command Purpose <code>geas init</code> Initialize GEAS in a repository. <code>geas identity</code> Manage identities (register humans/agents, generate keys). <code>geas new &lt;name&gt;</code> Create a new Bolt workspace. <code>geas checkout &lt;name&gt;</code> Switch active Bolt context. <code>geas seal intent</code> Seal Intent documents (human signature required). <code>geas prove</code> Run tests, generate MRP, and seal it. <code>geas verify</code> Validate Bolt against the configured workflow. <code>geas status</code> Display current Bolt state and seal status. <code>geas archive &lt;name&gt;</code> Archive a completed Bolt. <code>geas delete &lt;name&gt;</code> Permanently delete a Bolt."},{"location":"WHITE_PAPER/#roadmap-summary","title":"Roadmap Summary","text":"Phase Objective Deliverable Phase 1: Identity Establish the Keyring <code>geas init</code>, <code>geas identity</code>, SSH key generation Phase 2: Intent Engine Seal preliminary documents <code>geas seal intent</code>, hash chain ledger Phase 3: Proof Engine Generate and seal MRP <code>geas prove</code>, test runner, manifest generator Phase 4: Verification Workflow-based validation <code>geas verify</code>, workflow configuration Phase 5: Lifecycle Bolt management <code>geas archive</code>, <code>geas delete</code> Phase 6: CI Integration Enterprise automation GitHub Actions / GitLab CI templates"},{"location":"WHITE_PAPER/#conclusion","title":"Conclusion","text":"<p>GEAS provides the missing governance layer for the agentic development era. By separating Intent (what to build) from Code (how it's built) from Proof (evidence it works), and binding them with cryptographic signatures, GEAS creates an auditable, non-repudiable chain of custody that enables:</p> <ul> <li>Trust in agent-generated code.</li> <li>Compliance with enterprise security requirements.</li> <li>Collaboration between multiple agents and human overseers.</li> </ul> <p>The future of software engineering is not just faster code generation\u2014it's verifiable code generation. GEAS makes that possible.</p>"},{"location":"getting_started/","title":"Getting Started with GEAS-AI","text":"<p>Welcome to GEAS-AI (Governance Enforcement for Agentic Systems), the governance layer for Software Engineering 3.0. GEAS ensures that AI agents operate within a controlled, \"Spec-First\" environment, where every action is anchored in a cryptographically sealed blueprint.</p>"},{"location":"getting_started/#prerequisites","title":"\ud83d\udee0 Prerequisites","text":"<ul> <li>Python: 3.10 or higher.</li> <li>uv: We recommend using uv for fast and reliable package management.</li> </ul>"},{"location":"getting_started/#installation","title":"\ud83d\ude80 Installation","text":"<p>Install GEAS-AI using <code>uv</code>:</p> <pre><code>uv pip install geas-ai\n</code></pre> <p>Alternatively, you can run it directly without a permanent installation:</p> <pre><code>uv run geas --help\n</code></pre>"},{"location":"getting_started/#initializing-your-project","title":"\ud83c\udfd7 Initializing Your Project","text":"<p>To bootstrap GEAS in your repository, run:</p> <pre><code>geas init\n</code></pre> <p>This creates a <code>.geas/</code> directory containing:</p> <ul> <li><code>config/identities.yaml</code>: Registry of authorized Ed25519 public keys.</li> <li><code>config/agents.yaml</code>: Defines your AI team personas (Architect, Developer, QA, etc.).</li> <li><code>config/models.yaml</code>: Configures your LLM providers.</li> <li><code>bolts/</code>: The directory where all units of work (Bolts) will reside.</li> <li><code>active_context.md</code>: A pointer file indicating the current active Bolt.</li> </ul>"},{"location":"getting_started/#identity-setup","title":"\ud83d\udd11 Identity Setup","text":"<p>Before you can seal any critical documents (like the Intent or MRP), you need a cryptographic identity. GEAS uses Ed25519 keys to sign your actions.</p> <ol> <li> <p>Create your identity:    <code>bash    uv run geas identity add --name my-username --role human</code>    This generates a keypair. The private key is stored securely in <code>~/.geas/keys/</code> (0600 permissions), and the public key is added to the project's registry.</p> </li> <li> <p>Verify it exists:    <code>bash    uv run geas identity list</code></p> </li> </ol>"},{"location":"getting_started/#the-geas-workflow","title":"\u26a1\ufe0f The GEAS Workflow","text":"<p>GEAS enforces a rigorous lifecycle for every feature or bug fix, organized as a Bolt.</p> <pre><code>graph TD\n    Request --&gt; Specs --&gt; Plan --&gt; SealIntent((Seal Intent))\n    SealIntent --&gt; Code --&gt; Prove((Prove))\n    Prove --&gt; MRP --&gt; SealMRP((Seal MRP))\n    SealMRP --&gt; Approve((Approve))\n</code></pre>"},{"location":"getting_started/#1-create-a-new-bolt","title":"1. Create a New Bolt","text":"<p>Start a new unit of work:</p> <pre><code>geas new feature-name\n</code></pre> <p>This creates a folder in <code>.geas/bolts/feature-name/</code>, initializes the <code>lock.json</code> ledger, and sets it as the active context.</p>"},{"location":"getting_started/#2-the-blueprinting-process","title":"2. The Blueprinting Process","text":"<p>Every Bolt follows a standard sequence:</p> <ol> <li>Request (<code>01_request.md</code>): Define the user's intent or feature request.</li> <li>Specs (<code>02_specs.md</code>): The Spec Writer agent translates the request into technical requirements.</li> <li>Plan (<code>03_plan.md</code>): The Architect agent designs the implementation plan.</li> </ol>"},{"location":"getting_started/#3-sealing-the-intent","title":"3. Sealing the Intent","text":"<p>Before any code is written, the artifacts must be \"sealed\". You can seal them individually or as a complete Intent package.</p> <p>The Intent Seal requires a Human signature and locks all three documents (<code>req</code>, <code>specs</code>, <code>plan</code>):</p> <pre><code>geas seal intent --identity my-username\n</code></pre> <p>This creates a <code>SEAL_INTENT</code> event in the <code>lock.json</code> ledger, cryptographically linking your identity to the approved plan.</p>"},{"location":"getting_started/#4-implementation-and-verification","title":"4. Implementation and Verification","text":"<ol> <li>Code: The Developer executes the approved plan.</li> <li>Prove: Generate the Evidence:</li> </ol> <p><code>bash    geas prove</code></p> <p>This runs your tests and creates the <code>mrp/manifest.json</code> (Code Snapshot) and <code>mrp/tests.log</code>.</p> <ol> <li>MRP (<code>mrp/summary.md</code>): The QA Engineer reviews the evidence and writes the summary.</li> <li>Seal MRP: The QA Engineer (or Agent) seals the evidence:</li> </ol> <p><code>bash    geas seal mrp</code></p>"},{"location":"getting_started/#5-approval","title":"5. Approval","text":"<p>Finally, a Human identity (usually a Tech Lead or Maintainer) reviews the sealed package and provides final approval for the merge.</p> <pre><code>geas approve --identity my-username --comment \"Verified and ready to merge.\"\n</code></pre>"},{"location":"getting_started/#verification-and-status","title":"\ud83d\udee1 Verification and Status","text":"<p>At any point, you can check the status of your current Bolt:</p> <pre><code>geas status\n</code></pre> <p>Or verify the cryptographic integrity of all sealed artifacts and the hash chain:</p> <pre><code>geas verify\n</code></pre>"},{"location":"reference/","title":"API Reference","text":"<p>This section provides technical documentation for the internal GEAS-AI modules, automatically generated from the source code docstrings.</p>"},{"location":"reference/#cli-commands","title":"CLI Commands","text":""},{"location":"reference/#geas_ai.commands.init","title":"<code>geas_ai.commands.init</code>","text":""},{"location":"reference/#geas_ai.commands.init.init","title":"<code>init()</code>","text":"<p>Initialize the GEAS governance layer in the current directory.</p> <p>Creates the .geas/ directory structure and default configuration files. This includes config/agents.yaml, config/models.yaml, and GEAS_MANIFESTO.md.</p> Usage <p>$ geas init</p> Source code in <code>src/geas_ai/commands/init.py</code> <pre><code>def init() -&gt; None:\n    \"\"\"Initialize the GEAS governance layer in the current directory.\n\n    Creates the .geas/ directory structure and default configuration files.\n    This includes config/agents.yaml, config/models.yaml, and GEAS_MANIFESTO.md.\n\n    Usage:\n        $ geas init\n    \"\"\"\n    base_dir = \".geas\"\n\n    # 1. Check Pre-condition\n    if os.path.exists(base_dir):\n        console.print(\n            Panel(\n                \"[bold red]Error:[/bold red] GEAS is already initialized in this directory.\",\n                title=\"Initialization Failed\",\n            )\n        )\n        raise typer.Exit(code=1)\n\n    try:\n        # 2. Create Directory Structure\n        os.makedirs(os.path.join(base_dir, \"config\"), exist_ok=True)\n        os.makedirs(os.path.join(base_dir, \"bolts\"), exist_ok=True)\n        os.makedirs(os.path.join(base_dir, \"archive\"), exist_ok=True)\n\n        # 3. Create Configuration Files\n        with open(os.path.join(base_dir, \"config\", \"agents.yaml\"), \"w\") as f:\n            f.write(content.DEFAULT_AGENTS_YAML)\n\n        with open(os.path.join(base_dir, \"config\", \"models.yaml\"), \"w\") as f:\n            f.write(content.DEFAULT_MODELS_YAML)\n\n        with open(os.path.join(base_dir, \"config\", \"identities.yaml\"), \"w\") as f:\n            f.write(content.DEFAULT_IDENTITIES_YAML)\n\n        # 4. Create Default Workflow\n        yaml = YAML()\n        yaml.indent(mapping=2, sequence=4, offset=2)\n        workflow_path = os.path.join(base_dir, \"config\", \"workflow.yaml\")\n\n        # Convert Pydantic model to dict, handling enums if necessary (mode='json')\n        # However, we want clean YAML.\n        workflow_data = WorkflowManager.DEFAULT_WORKFLOW.model_dump(\n            mode=\"json\", exclude_none=True\n        )\n\n        with open(workflow_path, \"w\") as f:\n            yaml.dump(workflow_data, f)\n\n        # 5. Create Manifesto\n        with open(\"GEAS_MANIFESTO.md\", \"w\") as f:\n            f.write(content.MANIFESTO_CONTENT)\n\n        # 6. Success Message\n        console.print(\n            Panel(\n                f\"[bold green]Success![/bold green] GEAS initialized at [blue]{os.path.abspath(base_dir)}[/blue]\\n\\nCreated:\\n- .geas/config/agents.yaml\\n- .geas/config/models.yaml\\n- .geas/config/identities.yaml\\n- .geas/config/workflow.yaml\\n- GEAS_MANIFESTO.md\",\n                title=\"GEAS Protocol\",\n            )\n        )\n\n    except Exception as e:\n        console.print(\n            f\"[bold red]An error occurred during initialization:[/bold red] {e}\"\n        )\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.lifecycle","title":"<code>geas_ai.commands.lifecycle</code>","text":""},{"location":"reference/#geas_ai.commands.lifecycle.archive","title":"<code>archive(name)</code>","text":"<p>Archive a fully verified bolt.</p> <p>A bolt can only be archived if all artifacts (req, specs, plan, mrp) are sealed and verified.</p> Usage <p>$ geas archive feature-completed</p> Source code in <code>src/geas_ai/commands/lifecycle.py</code> <pre><code>def archive(name: str) -&gt; None:\n    \"\"\"Archive a fully verified bolt.\n\n    A bolt can only be archived if all artifacts (req, specs, plan, mrp) are sealed\n    and verified.\n\n    Usage:\n        $ geas archive feature-completed\n    \"\"\"\n    utils.ensure_geas_root()\n    bolt_dir = utils.get_geas_root() / \"bolts\" / name\n    archive_root = utils.get_geas_root() / \"archive\"\n\n    if not bolt_dir.exists():\n        console.print(f\"[bold red]Error:[/bold red] Bolt '{name}' does not exist.\")\n        raise typer.Exit(code=1)\n\n    # 1. Verification\n    console.print(f\"Verifying bolt '{name}' before archival...\")\n    try:\n        # Run verify logic (will exit 1 if fails)\n        run_verify(bolt=name)\n\n        lock_file = bolt_dir / \"approved.lock\"\n        import yaml\n\n        with open(lock_file) as f:\n            data = yaml.safe_load(f) or {}\n\n        required = [\"req\", \"specs\", \"plan\", \"mrp\"]\n        missing = [r for r in required if f\"{r}_hash\" not in data]\n        if missing:\n            console.print(\n                f\"[bold red]Archival Rejected:[/bold red] The following artifacts are not sealed: {', '.join(missing)}\"\n            )\n            raise typer.Exit(code=1)\n\n    except (typer.Exit, SystemExit) as e:\n        exit_code = getattr(e, \"exit_code\", getattr(e, \"code\", 0))\n        if exit_code != 0:\n            console.print(\n                \"[bold red]Archival Rejected:[/bold red] Bolt failed verification.\"\n            )\n            raise typer.Exit(code=exit_code)\n    except Exception as e:\n        console.print(f\"[bold red]Error during archival check:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n\n    # 2. Move\n    try:\n        os.makedirs(archive_root, exist_ok=True)\n        target_path = archive_root / name\n\n        if target_path.exists():\n            console.print(\n                f\"[bold red]Error:[/bold red] Bolt '{name}' already exists in archive. Rename it or delete the archive version first.\"\n            )\n            raise typer.Exit(code=1)\n\n        shutil.move(str(bolt_dir), str(target_path))\n        console.print(\n            f\"[bold green]Success![/bold green] Bolt '{name}' moved to archive.\"\n        )\n\n    except Exception as e:\n        console.print(f\"[bold red]Error moving bolt to archive:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.lifecycle.checkout","title":"<code>checkout(name)</code>","text":"<p>Switch the current active context to a different bolt.</p> Usage <p>$ geas checkout feature-login</p> Source code in <code>src/geas_ai/commands/lifecycle.py</code> <pre><code>def checkout(name: str) -&gt; None:\n    \"\"\"Switch the current active context to a different bolt.\n\n    Usage:\n        $ geas checkout feature-login\n    \"\"\"\n    utils.ensure_geas_root()\n    bolt_dir = utils.get_geas_root() / \"bolts\" / name\n\n    if not bolt_dir.exists():\n        console.print(f\"[bold red]Error:[/bold red] Bolt '{name}' does not exist.\")\n        raise typer.Exit(code=1)\n\n    # Update active_context.md\n    ctx_path = utils.get_geas_root() / \"active_context.md\"\n    timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    try:\n        with open(ctx_path, \"w\") as f:\n            f.write(\n                content.CONTEXT_TEMPLATE.format(bolt_name=name, timestamp=timestamp)\n            )\n\n        console.print(\n            Panel(\n                f\"[bold green]Switched to bolt:[/bold green] [blue]{name}[/blue]\",\n                title=\"geas checkout\",\n            )\n        )\n    except Exception as e:\n        console.print(f\"[bold red]Error updating context:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.lifecycle.delete","title":"<code>delete(name, force=typer.Option(False, '--force', '-f', help='Force deletion without confirmation'))</code>","text":"<p>Delete a bolt. Cannot delete the currently active bolt.</p> Usage <p>$ geas delete feature-obsolete</p> Source code in <code>src/geas_ai/commands/lifecycle.py</code> <pre><code>def delete(\n    name: str,\n    force: bool = typer.Option(\n        False, \"--force\", \"-f\", help=\"Force deletion without confirmation\"\n    ),\n) -&gt; None:\n    \"\"\"Delete a bolt. Cannot delete the currently active bolt.\n\n    Usage:\n        $ geas delete feature-obsolete\n    \"\"\"\n    utils.ensure_geas_root()\n\n    # Safety Check: Do not delete active bolt\n    try:\n        active_bolt = utils.get_active_bolt_name()\n        if name == active_bolt:\n            console.print(\n                f\"[bold red]Error:[/bold red] Cannot delete the active bolt '{name}'. Switch context first.\"\n            )\n            raise typer.Exit(code=1)\n    except Exception:\n        # If no active context, proceed with caution\n        pass\n\n    bolt_dir = utils.get_geas_root() / \"bolts\" / name\n    if not bolt_dir.exists():\n        console.print(f\"[bold red]Error:[/bold red] Bolt '{name}' does not exist.\")\n        raise typer.Exit(code=1)\n\n    if not force:\n        confirm = typer.confirm(f\"Are you sure you want to delete bolt '{name}'?\")\n        if not confirm:\n            raise typer.Abort()\n\n    try:\n        shutil.rmtree(bolt_dir)\n        console.print(f\"[bold green]Success:[/bold green] Bolt '{name}' deleted.\")\n    except Exception as e:\n        console.print(f\"[bold red]Error deleting bolt:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.lifecycle.new","title":"<code>new(name)</code>","text":"<p>Start a new GEAS Unit of Work (Bolt).</p> <p>Creates .geas/bolts// and updates .geas/active_context.md. <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the bolt (slugified).</p> required Usage <p>$ geas new feature-login</p> Source code in <code>src/geas_ai/commands/lifecycle.py</code> <pre><code>def new(name: str) -&gt; None:\n    \"\"\"Start a new GEAS Unit of Work (Bolt).\n\n    Creates .geas/bolts/&lt;name&gt;/ and updates .geas/active_context.md.\n\n    Args:\n        name: The name of the bolt (slugified).\n\n    Usage:\n        $ geas new feature-login\n    \"\"\"\n    try:\n        # 1. Validation\n        utils.ensure_geas_root()\n        utils.validate_slug(name)\n\n        bolt_dir = os.path.join(\".geas\", \"bolts\", name)\n\n        # 2. Check for existence (Idempotencyish warning)\n        if os.path.exists(bolt_dir):\n            console.print(f\"[bold red]Error:[/bold red] Bolt '{name}' already exists.\")\n            raise typer.Exit(code=1)\n\n        # 3. Create Structure\n        os.makedirs(bolt_dir)\n\n        # 4. Initialize Ledger (lock.json)\n        genesis = ledger.LedgerManager.create_genesis_ledger(bolt_id=name)\n        ledger.LedgerManager.save_lock(Path(bolt_dir), genesis)\n\n        # 5. Create Request File\n        req_path = os.path.join(bolt_dir, \"01_request.md\")\n        with open(req_path, \"w\") as f:\n            f.write(content.REQUEST_TEMPLATE.format(bolt_name=name))\n\n        # 6. Update Context\n        ctx_path = os.path.join(\".geas\", \"active_context.md\")\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        with open(ctx_path, \"w\") as f:\n            f.write(\n                content.CONTEXT_TEMPLATE.format(bolt_name=name, timestamp=timestamp)\n            )\n\n        # 7. Success Output\n        console.print(\n            Panel(\n                f\"[bold green]Bolt Started![/bold green]\\n\\nWorkspace: [blue]{bolt_dir}[/blue]\\nContext: [yellow]Updated[/yellow]\\nLedger: [yellow]Initialized[/yellow]\",\n                title=f\"Bolt: {name}\",\n            )\n        )\n\n    except Exception as e:\n        # If it's a Typer Exit, just re-raise\n        if isinstance(e, typer.Exit) or isinstance(e, typer.BadParameter):\n            raise e\n        console.print(f\"[bold red]Unexpected Error:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.seal","title":"<code>geas_ai.commands.seal</code>","text":""},{"location":"reference/#geas_ai.commands.seal.seal","title":"<code>seal(target=typer.Argument(..., help='Target to seal [req, specs, plan, mrp, intent]'), identity_name=typer.Option(None, '--identity', '-i', help='Identity to sign with (required for intent)'), context=typer.Option(None, '--context', '-c', help='Context message for the event'))</code>","text":"<p>Cryptographically seal the current Bolt's artifacts.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>The artifact to seal.</p> <code>Argument(..., help='Target to seal [req, specs, plan, mrp, intent]')</code> <code>identity_name</code> <code>Optional[str]</code> <p>The identity to sign with.</p> <code>Option(None, '--identity', '-i', help='Identity to sign with (required for intent)')</code> <code>context</code> <code>Optional[str]</code> <p>Context message.</p> <code>Option(None, '--context', '-c', help='Context message for the event')</code> Usage <p>$ geas seal req $ geas seal intent --identity arch-lead</p> Source code in <code>src/geas_ai/commands/seal.py</code> <pre><code>def seal(\n    target: str = typer.Argument(\n        ..., help=\"Target to seal [req, specs, plan, mrp, intent]\"\n    ),\n    identity_name: Optional[str] = typer.Option(\n        None, \"--identity\", \"-i\", help=\"Identity to sign with (required for intent)\"\n    ),\n    context: Optional[str] = typer.Option(\n        None, \"--context\", \"-c\", help=\"Context message for the event\"\n    ),\n) -&gt; None:\n    \"\"\"Cryptographically seal the current Bolt's artifacts.\n\n    Args:\n        target: The artifact to seal.\n        identity_name: The identity to sign with.\n        context: Context message.\n\n    Usage:\n        $ geas seal req\n        $ geas seal intent --identity arch-lead\n    \"\"\"\n    utils.ensure_geas_root()\n    bolt_path = utils.get_active_bolt_path()\n\n    # Load Ledger\n    ledger_obj = ledger.LedgerManager.load_lock(bolt_path)\n    if not ledger_obj:\n        console.print(\n            \"[bold red]Error:[/bold red] lock.json not found. Is this a valid bolt?\"\n        )\n        raise typer.Exit(code=1)\n\n    # Verify Chain Integrity before appending\n    if not ledger.LedgerManager.verify_chain_integrity(ledger_obj):\n        console.print(\n            \"[bold red]CRITICAL:[/bold red] Ledger integrity check failed! The chain is broken.\"\n        )\n        raise typer.Exit(code=1)\n\n    # Dispatch Logic\n    if target == \"intent\":\n        _seal_intent(bolt_path, ledger_obj, identity_name, context)\n    else:\n        _seal_artifact(bolt_path, ledger_obj, target, identity_name, context)\n\n    # Save Ledger\n    ledger.LedgerManager.save_lock(bolt_path, ledger_obj)\n\n    # ledger_obj.head_hash is Optional[str], but after seal it should be str.\n    head_hash_display = ledger_obj.head_hash[:12] if ledger_obj.head_hash else \"None\"\n\n    console.print(\n        Panel(\n            f\"[bold green]Sealed {target}![/bold green]\\nHead Hash: {head_hash_display}...\",\n            title=\"GEAS Seal\",\n        )\n    )\n</code></pre>"},{"location":"reference/#geas_ai.commands.status","title":"<code>geas_ai.commands.status</code>","text":""},{"location":"reference/#geas_ai.commands.status.status","title":"<code>status(bolt=typer.Option(None, '--bolt', '-b', help='Name of the bolt to check status for'))</code>","text":"<p>Display the current seal status of a bolt.</p> Usage <p>$ geas status $ geas status -b feature-login</p> Source code in <code>src/geas_ai/commands/status.py</code> <pre><code>def status(\n    bolt: Optional[str] = typer.Option(\n        None, \"--bolt\", \"-b\", help=\"Name of the bolt to check status for\"\n    ),\n) -&gt; None:\n    \"\"\"Display the current seal status of a bolt.\n\n    Usage:\n        $ geas status\n        $ geas status -b feature-login\n    \"\"\"\n    utils.ensure_geas_root()\n\n    if bolt:\n        bolt_path = utils.get_geas_root() / \"bolts\" / bolt\n        if not bolt_path.exists():\n            console.print(f\"[bold red]Error:[/bold red] Bolt '{bolt}' not found.\")\n            raise typer.Exit(code=1)\n    else:\n        bolt_path = utils.get_active_bolt_path()\n\n    # Load Ledger\n    ledger = LedgerManager.load_lock(bolt_path)\n\n    if not ledger or not ledger.events:\n        console.print(\n            f\"[yellow]No ledger (lock.json) found or empty for bolt '{bolt_path.name}'. Not Sealed.[/yellow]\"\n        )\n        return\n\n    # Display Header\n    console.print(f\"[bold]Bolt:[/bold] {ledger.bolt_id}\")\n    console.print(f\"[bold]Created:[/bold] {ledger.created_at}\")\n\n    # Determine State (Last Event)\n    last_event = ledger.events[-1]\n    state_display = f\"[cyan]{last_event.action.value}[/cyan]\"\n    console.print(f\"[bold]Current State:[/bold] {state_display}\")\n    console.print()\n\n    # Events Table\n    table = Table(title=f\"Event History: {bolt_path.name}\")\n    table.add_column(\"Seq\", style=\"dim\", justify=\"right\")\n    table.add_column(\"Timestamp\", style=\"green\")\n    table.add_column(\"Action\", style=\"cyan\")\n    table.add_column(\"Signer\", style=\"magenta\")\n\n    for event in ledger.events:\n        signer = \"-\"\n        if event.identity:\n            signer = f\"{event.identity.signer_id}\"\n\n        table.add_row(\n            str(event.sequence),\n            event.timestamp.strftime(\"%Y-%m-%d %H:%M:%S\"),\n            event.action.value,\n            signer,\n        )\n\n    console.print(table)\n</code></pre>"},{"location":"reference/#geas_ai.commands.verify","title":"<code>geas_ai.commands.verify</code>","text":""},{"location":"reference/#geas_ai.commands.verify.verify","title":"<code>verify(bolt=typer.Option(None, '--bolt', '-b', help='Name of the bolt to verify'), check_content=typer.Option(False, '--content', help='Also verify sealed file contents match hashes'), json_output=typer.Option(False, '--json', help='Output results as JSON'))</code>","text":"<p>Verify the cryptographic integrity and governance compliance of a bolt.</p> Usage <p>$ geas verify $ geas verify --content $ geas verify --json</p> Source code in <code>src/geas_ai/commands/verify.py</code> <pre><code>def verify(\n    bolt: Optional[str] = typer.Option(\n        None, \"--bolt\", \"-b\", help=\"Name of the bolt to verify\"\n    ),\n    check_content: bool = typer.Option(\n        False, \"--content\", help=\"Also verify sealed file contents match hashes\"\n    ),\n    json_output: bool = typer.Option(False, \"--json\", help=\"Output results as JSON\"),\n) -&gt; None:\n    \"\"\"Verify the cryptographic integrity and governance compliance of a bolt.\n\n    Usage:\n        $ geas verify\n        $ geas verify --content\n        $ geas verify --json\n    \"\"\"\n    utils.ensure_geas_root()\n\n    if bolt:\n        bolt_path = utils.get_geas_root() / \"bolts\" / bolt\n        if not bolt_path.exists():\n            console.print(f\"[bold red]Error:[/bold red] Bolt '{bolt}' not found.\")\n            raise typer.Exit(code=1)\n    else:\n        bolt_path = utils.get_active_bolt_path()\n\n    # 1. Load Data\n    ledger = LedgerManager.load_lock(bolt_path)\n    if not ledger:\n        msg = f\"No lock.json found for bolt '{bolt_path.name}'.\"\n        if json_output:\n            print(json.dumps({\"error\": msg, \"valid\": False}))\n        else:\n            console.print(f\"[bold red]Fail:[/bold red] {msg}\")\n        raise typer.Exit(code=1)\n\n    workflow_config = (\n        workflow_core.WorkflowManager.load_workflow()\n    )  # Loads default if missing\n\n    id_manager = IdentityManager()\n    identities = id_manager.load()\n\n    # 2. Run Validations\n    chain_res = verification.validate_chain_integrity(ledger)\n    sig_res = verification.validate_signatures(ledger, identities)\n    flow_res = verification.validate_workflow_compliance(\n        ledger, workflow_config, identities\n    )\n\n    content_res = None\n    if check_content:\n        content_res = verification.validate_content_integrity(ledger, bolt_path)\n\n    # 3. Aggregate Results\n    overall_valid = chain_res.valid and sig_res.valid and flow_res.valid\n    if content_res:\n        overall_valid = overall_valid and content_res.valid\n\n    # 4. Output\n    if json_output:\n        output = {\n            \"bolt\": bolt_path.name,\n            \"valid\": overall_valid,\n            \"chain\": chain_res.model_dump(mode=\"json\"),\n            \"signatures\": sig_res.model_dump(mode=\"json\"),\n            \"workflow\": flow_res.model_dump(mode=\"json\"),\n        }\n        if content_res:\n            output[\"content\"] = content_res.model_dump(mode=\"json\")\n        print(json.dumps(output, indent=2))\n    else:\n        _print_report(\n            bolt_path.name, overall_valid, chain_res, sig_res, flow_res, content_res\n        )\n\n    if not overall_valid:\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.agents","title":"<code>geas_ai.commands.agents</code>","text":""},{"location":"reference/#geas_ai.commands.agents.agents","title":"<code>agents()</code>","text":"<p>List the currently active agents configuration.</p> Source code in <code>src/geas_ai/commands/agents.py</code> <pre><code>def agents() -&gt; None:\n    \"\"\"List the currently active agents configuration.\"\"\"\n    utils.ensure_geas_root()\n\n    # Read from global .geas/config/agents.yaml\n    config_path = utils.get_geas_root() / \"config/agents.yaml\"\n\n    if not config_path.exists():\n        utils.console.print(\n            f\"[bold red]Error:[/bold red] Agent configuration not found at {config_path}\"\n        )\n        raise typer.Exit(code=1)\n\n    try:\n        with open(config_path, \"r\", encoding=\"utf-8\") as f:\n            data = yaml.safe_load(f)\n    except Exception as e:\n        utils.console.print(\n            f\"[bold red]Error:[/bold red] Failed to parse agents.yaml: {e}\"\n        )\n        raise typer.Exit(code=1)\n\n    if not data or \"agents\" not in data:\n        utils.console.print(\n            \"[bold yellow]Warning:[/bold yellow] No agents defined in agents.yaml\"\n        )\n        return\n\n    table = Table(title=\"GEAS Agents Roster (Global)\")\n    table.add_column(\"Agent Name\", style=\"cyan\", no_wrap=True)\n    table.add_column(\"Role\", style=\"magenta\")\n    table.add_column(\"Goal\", style=\"green\")\n\n    # Sort agents for consistent display\n    for agent_name, agent_info in sorted(data[\"agents\"].items()):\n        role = agent_info.get(\"role\", \"N/A\")\n        goal = agent_info.get(\"goal\", \"N/A\")\n        table.add_row(agent_name, role, goal)\n\n    utils.console.print(table)\n</code></pre>"},{"location":"reference/#geas_ai.commands.identity","title":"<code>geas_ai.commands.identity</code>","text":""},{"location":"reference/#geas_ai.commands.identity.add_identity","title":"<code>add_identity(name=typer.Option(..., '--name', '-n', help='Unique name for the identity.'), role=typer.Option(..., '--role', '-r', help=\"Role: 'human' or 'agent'.\"), persona=typer.Option(None, '--persona', '-p', help='Persona (required if role is agent).'), model=typer.Option(None, '--model', '-m', help='Model (required if role is agent).'))</code>","text":"<p>Create a new identity and generate an Ed25519 keypair.</p> Source code in <code>src/geas_ai/commands/identity.py</code> <pre><code>@app.command(\"add\")\ndef add_identity(\n    name: str = typer.Option(..., \"--name\", \"-n\", help=\"Unique name for the identity.\"),\n    role: str = typer.Option(..., \"--role\", \"-r\", help=\"Role: 'human' or 'agent'.\"),\n    persona: str = typer.Option(\n        None, \"--persona\", \"-p\", help=\"Persona (required if role is agent).\"\n    ),\n    model: str = typer.Option(\n        None, \"--model\", \"-m\", help=\"Model (required if role is agent).\"\n    ),\n) -&gt; None:\n    \"\"\"\n    Create a new identity and generate an Ed25519 keypair.\n    \"\"\"\n    try:\n        # Validate Role\n        if role not in [r.value for r in IdentityRole]:\n            console.print(\n                f\"[bold red]Error:[/bold red] Invalid role '{role}'. Must be 'human' or 'agent'.\"\n            )\n            raise typer.Exit(code=1)\n\n        role_enum = IdentityRole(role)\n\n        # Generate Keypair\n        private_bytes, public_str = generate_keypair()\n\n        # Save Private Key\n        keys_dir = Path(os.path.expanduser(\"~/.geas/keys\"))\n        keys_dir.mkdir(parents=True, exist_ok=True)\n        key_path = keys_dir / f\"{name}.key\"\n\n        if key_path.exists():\n            console.print(\n                f\"[bold red]Error:[/bold red] Key file already exists: {key_path}\"\n            )\n            raise typer.Exit(code=1)\n\n        # Write private key (mode 0600)\n        # Using os.open to ensure permissions from start\n        fd = os.open(str(key_path), os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o600)\n        with os.fdopen(fd, \"wb\") as f:\n            f.write(private_bytes)\n\n        # Create Identity Object\n        identity = Identity(\n            name=name,\n            role=role_enum,\n            persona=persona,\n            model=model,\n            active_key=public_str,\n        )\n\n        # Add to Identity Store\n        manager = IdentityManager()\n        manager.add_identity(identity)\n\n        console.print(f\"[bold green]Success![/bold green] Identity '{name}' created.\")\n        console.print(f\"Private key saved to: [blue]{key_path}[/blue]\")\n\n        if role_enum == IdentityRole.AGENT:\n            # We need to print the env var export for the user\n            # Convert private key to base64 for env var\n            import base64\n\n            b64_key = base64.b64encode(private_bytes).decode(\"utf-8\")\n            env_var = f\"GEAS_KEY_{name.upper().replace('-', '_')}\"\n            console.print(\n                \"\\n[yellow]For Agent usage, set this environment variable:[/yellow]\"\n            )\n            console.print(f'export {env_var}=\"{b64_key}\"')\n\n    except ValueError as e:\n        console.print(f\"[bold red]Validation Error:[/bold red] {e}\")\n        # Clean up key file if it was created\n        if \"key_path\" in locals() and key_path.exists():\n            os.remove(key_path)\n        raise typer.Exit(code=1)\n    except Exception as e:\n        console.print(f\"[bold red]Error:[/bold red] {e}\")\n        if \"key_path\" in locals() and key_path.exists():\n            os.remove(key_path)\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.identity.list_identities","title":"<code>list_identities()</code>","text":"<p>List all registered identities.</p> Source code in <code>src/geas_ai/commands/identity.py</code> <pre><code>@app.command(\"list\")\ndef list_identities() -&gt; None:\n    \"\"\"\n    List all registered identities.\n    \"\"\"\n    manager = IdentityManager()\n    try:\n        store = manager.load()\n    except Exception as e:\n        console.print(f\"[bold red]Error loading identities:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n\n    table = Table(title=\"GEAS Identities\")\n    table.add_column(\"Name\", style=\"cyan\")\n    table.add_column(\"Role\", style=\"magenta\")\n    table.add_column(\"Persona\", style=\"green\")\n    table.add_column(\"Model\", style=\"blue\")\n    table.add_column(\"Active Key (Fingerprint)\", style=\"yellow\")\n\n    for i in store.identities:\n        # Simple truncation for \"fingerprint\" like display\n        key_display = (\n            i.active_key.split()[1][:16] + \"...\"\n            if len(i.active_key.split()) &gt; 1\n            else \"Invalid\"\n        )\n        table.add_row(\n            i.name, i.role.value, i.persona or \"-\", i.model or \"-\", key_display\n        )\n\n    console.print(table)\n</code></pre>"},{"location":"reference/#geas_ai.commands.identity.revoke_identity","title":"<code>revoke_identity(name, confirm=typer.Option(False, '--yes', '-y', help='Skip confirmation prompt.'))</code>","text":"<p>Revoke the current key for an identity and rotate to a new one.</p> Source code in <code>src/geas_ai/commands/identity.py</code> <pre><code>@app.command(\"revoke\")\ndef revoke_identity(\n    name: str,\n    confirm: bool = typer.Option(\n        False, \"--yes\", \"-y\", help=\"Skip confirmation prompt.\"\n    ),\n) -&gt; None:\n    \"\"\"\n    Revoke the current key for an identity and rotate to a new one.\n    \"\"\"\n    manager = IdentityManager()\n    try:\n        store = manager.load()\n    except Exception as e:\n        console.print(f\"[bold red]Error loading identities:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n\n    identity = store.get_by_name(name)\n    if not identity:\n        console.print(f\"[bold red]Error:[/bold red] Identity '{name}' not found.\")\n        raise typer.Exit(code=1)\n\n    if not confirm:\n        if not typer.confirm(\n            f\"Are you sure you want to revoke and rotate the key for '{name}'?\"\n        ):\n            raise typer.Abort()\n\n    try:\n        # 1. Archive current key\n        old_key = identity.active_key\n        identity.revoked_keys.append(old_key)\n\n        # 2. Generate new key\n        private_bytes, public_str = generate_keypair()\n        identity.active_key = public_str\n\n        # 3. Save new private key\n        keys_dir = Path(os.path.expanduser(\"~/.geas/keys\"))\n        keys_dir.mkdir(parents=True, exist_ok=True)\n        key_path = keys_dir / f\"{name}.key\"\n\n        # Overwrite existing key file (rotation)\n        fd = os.open(str(key_path), os.O_WRONLY | os.O_CREAT | os.O_TRUNC, 0o600)\n        with os.fdopen(fd, \"wb\") as f:\n            f.write(private_bytes)\n\n        # 4. Save Identity Update\n        manager.save(store)\n\n        console.print(f\"[bold green]Success![/bold green] Key for '{name}' rotated.\")\n        console.print(f\"New private key saved to: [blue]{key_path}[/blue]\")\n\n        if identity.role == IdentityRole.AGENT:\n            import base64\n\n            b64_key = base64.b64encode(private_bytes).decode(\"utf-8\")\n            env_var = f\"GEAS_KEY_{name.upper().replace('-', '_')}\"\n            console.print(\n                \"\\n[yellow]For Agent usage, UPDATE this environment variable:[/yellow]\"\n            )\n            console.print(f'export {env_var}=\"{b64_key}\"')\n\n    except Exception as e:\n        console.print(f\"[bold red]Error during revocation:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#geas_ai.commands.identity.show_identity","title":"<code>show_identity(name)</code>","text":"<p>Show details of a specific identity.</p> Source code in <code>src/geas_ai/commands/identity.py</code> <pre><code>@app.command(\"show\")\ndef show_identity(name: str) -&gt; None:\n    \"\"\"\n    Show details of a specific identity.\n    \"\"\"\n    manager = IdentityManager()\n    try:\n        store = manager.load()\n    except Exception as e:\n        console.print(f\"[bold red]Error loading identities:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n\n    identity = store.get_by_name(name)\n    if not identity:\n        console.print(f\"[bold red]Error:[/bold red] Identity '{name}' not found.\")\n        raise typer.Exit(code=1)\n\n    console.print(f\"[bold cyan]Identity: {identity.name}[/bold cyan]\")\n    console.print(f\"  Role: {identity.role.value}\")\n    if identity.persona:\n        console.print(f\"  Persona: {identity.persona}\")\n    if identity.model:\n        console.print(f\"  Model: {identity.model}\")\n    console.print(f\"  Created At: {identity.created_at}\")\n    console.print(f\"  Active Key: [yellow]{identity.active_key}[/yellow]\")\n    if identity.revoked_keys:\n        console.print(f\"  Revoked Keys ({len(identity.revoked_keys)}):\")\n        for k in identity.revoked_keys:\n            console.print(f\"    - [red]{k}[/red]\")\n    else:\n        console.print(\"  Revoked Keys: None\")\n</code></pre>"},{"location":"reference/#geas_ai.commands.prove","title":"<code>geas_ai.commands.prove</code>","text":""},{"location":"reference/#geas_ai.commands.prove.prove","title":"<code>prove(scope=typer.Option('src,tests', help='Comma-separated directories to include in proof'), skip_tests=typer.Option(False, help='Skip running tests (debugging only)'), command=typer.Option('uv run pytest', help='Command to run tests'), timeout=typer.Option(300, help='Test timeout in seconds'))</code>","text":"<p>Generates a cryptographic proof of the codebase (Code Merkle Tree) and binds it to test results. Does NOT seal the MRP (that happens after manual summary).</p> Source code in <code>src/geas_ai/commands/prove.py</code> <pre><code>@app.command()\ndef prove(\n    scope: str = typer.Option(\n        \"src,tests\", help=\"Comma-separated directories to include in proof\"\n    ),\n    skip_tests: bool = typer.Option(False, help=\"Skip running tests (debugging only)\"),\n    command: str = typer.Option(\"uv run pytest\", help=\"Command to run tests\"),\n    timeout: int = typer.Option(300, help=\"Test timeout in seconds\"),\n) -&gt; None:\n    \"\"\"\n    Generates a cryptographic proof of the codebase (Code Merkle Tree) and binds it to test results.\n    Does NOT seal the MRP (that happens after manual summary).\n    \"\"\"\n    try:\n        root_dir = ensure_geas_root()\n        bolt_id = get_active_bolt_name()\n\n        # 1. State Check: Is SEAL_INTENT present?\n        bolt_path = root_dir / \".geas\" / \"bolts\" / bolt_id\n        ledger = LedgerManager.load_lock(bolt_path)\n\n        if not ledger:\n            print(\n                f\"[bold red]Error:[/bold red] Ledger not found for bolt '[cyan]{bolt_id}[/cyan]'.\"\n            )\n            raise typer.Exit(code=1)\n\n        has_sealed_intent = any(e.action == \"SEAL_INTENT\" for e in ledger.events)\n\n        if not has_sealed_intent:\n            print(\n                f\"[bold red]Error:[/bold red] Intent not sealed for bolt '[cyan]{bolt_id}[/cyan]'. Cannot proceed to Prove phase.\"\n            )\n            raise typer.Exit(code=1)\n\n        # 2. Testing\n        if skip_tests:\n            print(\"[yellow]Skipping tests as requested.[/yellow]\")\n            from geas_ai.core.manifest import TestResultInfo\n\n            test_result = TestResultInfo(\n                passed=True,  # Tentatively true if skipped? Or should be marked specially?\n                # Specs say \"Skip tests (Flag) For manual override/debugging\".\n                exit_code=0,\n                duration_seconds=0.0,\n                timestamp=datetime.now(timezone.utc),\n            )\n        else:\n            print(f\"[bold blue]Running tests...[/bold blue] ({command})\")\n            test_result = run_tests(command, timeout)\n\n            if not test_result.passed:\n                print(\n                    f\"[bold red]Tests Failed![/bold red] (Exit Code: {test_result.exit_code})\"\n                )\n                # We can write the log but we should exit and NOT generate manifest?\n                # Specs: \"If fail -&gt; Exit.\"\n                # But we might want to see the logs.\n                # Let's write logs and exit.\n                # Actually specs say: \"Output: Print success message...\". Implicitly if fail, we assume we stop?\n                # \"Scenario: Test Failure Abort ... manifest should not be created\".\n                print(\"[red]Aborting proof generation due to test failure.[/red]\")\n                raise typer.Exit(code=1)\n            else:\n                print(\n                    f\"[bold green]Tests Passed![/bold green] ({test_result.duration_seconds:.2f}s)\"\n                )\n\n        # 3. Manifesting\n        scope_list = [s.strip() for s in scope.split(\",\")]\n\n        # Check scope existence (warn if missing)\n        for s in scope_list:\n            if not (root_dir / s).exists():\n                print(f\"[yellow]Warning:[/yellow] Scope directory '{s}' not found.\")\n\n        files = walk_source_files(root_dir, scope_list)\n\n        if not files:\n            print(\"[bold red]Error:[/bold red] No files found in the specified scope.\")\n            raise typer.Exit(code=1)\n\n        print(f\"Hashing {len(files)} files...\")\n        file_hashes = {}\n        for fpath in files:\n            full_path = root_dir / fpath\n            with open(full_path, \"rb\") as f:\n                content = f.read()\n                file_hashes[fpath] = hashlib.sha256(content).hexdigest()\n\n        manifest = generate_manifest(bolt_id, scope_list, file_hashes, test_result)\n\n        # 4. Artifact Generation\n        bolt_dir = root_dir / \".geas\" / \"bolts\" / bolt_id\n        mrp_dir = bolt_dir / \"mrp\"\n        mrp_dir.mkdir(parents=True, exist_ok=True)\n\n        manifest_path = mrp_dir / \"manifest.json\"\n        tests_log_path = mrp_dir / \"tests.log\"\n\n        with open(manifest_path, \"w\") as f:\n            f.write(manifest.model_dump_json(indent=2))\n\n        # Write a simple log file for tests (could be more detailed if we captured stdout)\n        # run_tests returns a simple object. If we want full logs we'd need to modify run_tests to return stdout.\n        # The current run_tests implementation captures output but doesn't return it in the struct.\n        # I should probably update run_tests to return output if I need to write it to tests.log.\n        # For now I will just write the summary in tests.log as the specs define \"mrp/tests.log\" but not its content.\n        # Wait, usually a log file contains the output.\n        # I will update run_tests to include output in the model or return it separately?\n        # The TestResultInfo model in the specs didn't have 'output'.\n        # I'll stick to what I have, maybe just writing the metadata to tests.log for now,\n        # OR I should update `TestResultInfo` to include `output`.\n        # Let's assume for now I should just log the result info.\n        # Note: Ideally I would change TestResultInfo to include stdout/stderr.\n        # Let's verify the `TestResultInfo` definition I created.\n\n        with open(tests_log_path, \"w\") as f:\n            f.write(\"Test Execution Log\\n\")\n            f.write(f\"Timestamp: {test_result.timestamp}\\n\")\n            f.write(f\"Command: {command}\\n\")\n            f.write(f\"Passed: {test_result.passed}\\n\")\n            f.write(f\"Exit Code: {test_result.exit_code}\\n\")\n            f.write(f\"Duration: {test_result.duration_seconds}s\\n\")\n            f.write(\"-\" * 40 + \"\\n\")\n            f.write(test_result.output)\n\n        # 5. Output\n        print(\n            Panel(\n                f\"[green]Proof Generated Successfully![/green]\\n\\n\"\n                f\"Manifest: [bold]{manifest_path}[/bold]\\n\"\n                f\"Root Hash: [cyan]{manifest.root_hash}[/cyan]\\n\\n\"\n                \"Next Steps:\\n\"\n                \"1. Review the proof artifacts in [bold]mrp/[/bold].\\n\"\n                \"2. Write a qualitative report in [bold]mrp/summary.md[/bold].\\n\"\n                \"3. Run [bold]geas seal mrp[/bold] to finalize.\",\n                title=\"GEAS Proof Engine\",\n            )\n        )\n\n    except Exception as e:\n        if isinstance(e, typer.Exit):\n            raise e\n        print(f\"[bold red]An unexpected error occurred:[/bold red] {e}\")\n        raise typer.Exit(code=1)\n</code></pre>"},{"location":"reference/#core-logic","title":"Core Logic","text":""},{"location":"reference/#geas_ai.core.identity","title":"<code>geas_ai.core.identity</code>","text":""},{"location":"reference/#geas_ai.core.identity.IdentityManager","title":"<code>IdentityManager</code>","text":"<p>Manages reading and writing identities to identities.yaml.</p> Source code in <code>src/geas_ai/core/identity.py</code> <pre><code>class IdentityManager:\n    \"\"\"Manages reading and writing identities to identities.yaml.\"\"\"\n\n    def __init__(self, config_path: Optional[Path] = None):\n        if config_path:\n            self.config_path = config_path\n        else:\n            self.config_path = get_geas_root() / \"config\" / \"identities.yaml\"\n        self.yaml = YAML()\n        self.yaml.preserve_quotes = True\n\n    def load(self) -&gt; IdentityStore:\n        \"\"\"Loads identities from the YAML file.\"\"\"\n        if not self.config_path.exists():\n            return IdentityStore(identities=[])\n\n        try:\n            with open(self.config_path, \"r\") as f:\n                data = self.yaml.load(f) or {}\n                # Handle empty file or null data\n                if not data:\n                    return IdentityStore(identities=[])\n                # If data has 'identities' key, use it. If list, wrap it?\n                # Spec implies structure is: identities: [ ... ]\n                if \"identities\" not in data:\n                    return IdentityStore(identities=[])\n\n                # Convert raw dicts to Identity objects\n                # Pydantic validation happens here\n                return IdentityStore(**data)\n        except Exception as e:\n            # Maybe raise a custom error or return empty?\n            # For now, let's propagate or raise helpful error\n            raise ValueError(f\"Failed to load identities from {self.config_path}: {e}\")\n\n    def save(self, store: IdentityStore) -&gt; None:\n        \"\"\"Saves the IdentityStore to the YAML file.\"\"\"\n        # Ensure directory exists\n        self.config_path.parent.mkdir(parents=True, exist_ok=True)\n\n        # Dump to dict\n        data = store.model_dump(mode=\"json\")\n\n        with open(self.config_path, \"w\") as f:\n            self.yaml.dump(data, f)\n\n    def add_identity(self, identity: Identity) -&gt; None:\n        \"\"\"Adds a new identity and saves.\"\"\"\n        store = self.load()\n        # Check uniqueness\n        if store.get_by_name(identity.name):\n            raise ValueError(f\"Identity with name '{identity.name}' already exists.\")\n\n        store.identities.append(identity)\n        self.save(store)\n</code></pre>"},{"location":"reference/#geas_ai.core.identity.IdentityManager.add_identity","title":"<code>add_identity(identity)</code>","text":"<p>Adds a new identity and saves.</p> Source code in <code>src/geas_ai/core/identity.py</code> <pre><code>def add_identity(self, identity: Identity) -&gt; None:\n    \"\"\"Adds a new identity and saves.\"\"\"\n    store = self.load()\n    # Check uniqueness\n    if store.get_by_name(identity.name):\n        raise ValueError(f\"Identity with name '{identity.name}' already exists.\")\n\n    store.identities.append(identity)\n    self.save(store)\n</code></pre>"},{"location":"reference/#geas_ai.core.identity.IdentityManager.load","title":"<code>load()</code>","text":"<p>Loads identities from the YAML file.</p> Source code in <code>src/geas_ai/core/identity.py</code> <pre><code>def load(self) -&gt; IdentityStore:\n    \"\"\"Loads identities from the YAML file.\"\"\"\n    if not self.config_path.exists():\n        return IdentityStore(identities=[])\n\n    try:\n        with open(self.config_path, \"r\") as f:\n            data = self.yaml.load(f) or {}\n            # Handle empty file or null data\n            if not data:\n                return IdentityStore(identities=[])\n            # If data has 'identities' key, use it. If list, wrap it?\n            # Spec implies structure is: identities: [ ... ]\n            if \"identities\" not in data:\n                return IdentityStore(identities=[])\n\n            # Convert raw dicts to Identity objects\n            # Pydantic validation happens here\n            return IdentityStore(**data)\n    except Exception as e:\n        # Maybe raise a custom error or return empty?\n        # For now, let's propagate or raise helpful error\n        raise ValueError(f\"Failed to load identities from {self.config_path}: {e}\")\n</code></pre>"},{"location":"reference/#geas_ai.core.identity.IdentityManager.save","title":"<code>save(store)</code>","text":"<p>Saves the IdentityStore to the YAML file.</p> Source code in <code>src/geas_ai/core/identity.py</code> <pre><code>def save(self, store: IdentityStore) -&gt; None:\n    \"\"\"Saves the IdentityStore to the YAML file.\"\"\"\n    # Ensure directory exists\n    self.config_path.parent.mkdir(parents=True, exist_ok=True)\n\n    # Dump to dict\n    data = store.model_dump(mode=\"json\")\n\n    with open(self.config_path, \"w\") as f:\n        self.yaml.dump(data, f)\n</code></pre>"},{"location":"reference/#geas_ai.core.identity.KeyManager","title":"<code>KeyManager</code>","text":"<p>Handles resolution and loading of private keys.</p> Source code in <code>src/geas_ai/core/identity.py</code> <pre><code>class KeyManager:\n    \"\"\"Handles resolution and loading of private keys.\"\"\"\n\n    @staticmethod\n    def load_private_key(identity_name: str) -&gt; object:\n        \"\"\"\n        Resolves and loads the private key for the given identity name.\n\n        Priority:\n        1. Environment Variable: GEAS_KEY_{NAME} (Content: PEM or Base64)\n        2. Local File: ~/.geas/keys/{name}.key\n\n        Returns:\n            Ed25519PrivateKey object.\n\n        Raises:\n            KeyNotFoundError: If no key is found.\n            CryptoError: If the key is invalid.\n        \"\"\"\n        # 1. Environment Variable Check\n        env_var_name = f\"GEAS_KEY_{identity_name.upper().replace('-', '_')}\"\n        env_val = os.getenv(env_var_name)\n        if env_val:\n            try:\n                # Handle Base64 encoded or direct PEM content\n                # If it looks like PEM (starts with -----BEGIN), use as is\n                if env_val.strip().startswith(\"-----BEGIN\"):\n                    key_bytes = env_val.encode(\"utf-8\")\n                else:\n                    # Assume base64\n                    import base64\n\n                    key_bytes = base64.b64decode(env_val)\n                return load_private_key_from_bytes(key_bytes)\n            except Exception as e:\n                # Fallthrough not implied by spec but good practice to log?\n                # Spec says \"Decode value... Parse... Return\". If fail, maybe raise?\n                # Spec says \"Error State: Raise KeyNotFoundError\" if *not found*.\n                # If found but invalid, CryptoError seems appropriate.\n                raise CryptoError(\n                    f\"Invalid key in environment variable {env_var_name}: {e}\"\n                )\n\n        # 2. Local File Check\n        key_path = Path(os.path.expanduser(f\"~/.geas/keys/{identity_name}.key\"))\n        if key_path.exists():\n            try:\n                key_bytes = key_path.read_bytes()\n                return load_private_key_from_bytes(key_bytes)\n            except Exception as e:\n                raise CryptoError(f\"Invalid key in file {key_path}: {e}\")\n\n        # 3. Not Found\n        raise KeyNotFoundError(\n            f\"Private key for '{identity_name}' not found in env ({env_var_name}) or local storage ({key_path}).\"\n        )\n</code></pre>"},{"location":"reference/#geas_ai.core.identity.KeyManager.load_private_key","title":"<code>load_private_key(identity_name)</code>  <code>staticmethod</code>","text":"<p>Resolves and loads the private key for the given identity name.</p> <p>Priority: 1. Environment Variable: GEAS_KEY_{NAME} (Content: PEM or Base64) 2. Local File: ~/.geas/keys/{name}.key</p> <p>Returns:</p> Type Description <code>object</code> <p>Ed25519PrivateKey object.</p> <p>Raises:</p> Type Description <code>KeyNotFoundError</code> <p>If no key is found.</p> <code>CryptoError</code> <p>If the key is invalid.</p> Source code in <code>src/geas_ai/core/identity.py</code> <pre><code>@staticmethod\ndef load_private_key(identity_name: str) -&gt; object:\n    \"\"\"\n    Resolves and loads the private key for the given identity name.\n\n    Priority:\n    1. Environment Variable: GEAS_KEY_{NAME} (Content: PEM or Base64)\n    2. Local File: ~/.geas/keys/{name}.key\n\n    Returns:\n        Ed25519PrivateKey object.\n\n    Raises:\n        KeyNotFoundError: If no key is found.\n        CryptoError: If the key is invalid.\n    \"\"\"\n    # 1. Environment Variable Check\n    env_var_name = f\"GEAS_KEY_{identity_name.upper().replace('-', '_')}\"\n    env_val = os.getenv(env_var_name)\n    if env_val:\n        try:\n            # Handle Base64 encoded or direct PEM content\n            # If it looks like PEM (starts with -----BEGIN), use as is\n            if env_val.strip().startswith(\"-----BEGIN\"):\n                key_bytes = env_val.encode(\"utf-8\")\n            else:\n                # Assume base64\n                import base64\n\n                key_bytes = base64.b64decode(env_val)\n            return load_private_key_from_bytes(key_bytes)\n        except Exception as e:\n            # Fallthrough not implied by spec but good practice to log?\n            # Spec says \"Decode value... Parse... Return\". If fail, maybe raise?\n            # Spec says \"Error State: Raise KeyNotFoundError\" if *not found*.\n            # If found but invalid, CryptoError seems appropriate.\n            raise CryptoError(\n                f\"Invalid key in environment variable {env_var_name}: {e}\"\n            )\n\n    # 2. Local File Check\n    key_path = Path(os.path.expanduser(f\"~/.geas/keys/{identity_name}.key\"))\n    if key_path.exists():\n        try:\n            key_bytes = key_path.read_bytes()\n            return load_private_key_from_bytes(key_bytes)\n        except Exception as e:\n            raise CryptoError(f\"Invalid key in file {key_path}: {e}\")\n\n    # 3. Not Found\n    raise KeyNotFoundError(\n        f\"Private key for '{identity_name}' not found in env ({env_var_name}) or local storage ({key_path}).\"\n    )\n</code></pre>"},{"location":"reference/#geas_ai.core.identity.KeyNotFoundError","title":"<code>KeyNotFoundError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a private key cannot be resolved.</p> Source code in <code>src/geas_ai/core/identity.py</code> <pre><code>class KeyNotFoundError(Exception):\n    \"\"\"Raised when a private key cannot be resolved.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#geas_ai.core.ledger","title":"<code>geas_ai.core.ledger</code>","text":""},{"location":"reference/#geas_ai.core.ledger.LedgerIntegrityError","title":"<code>LedgerIntegrityError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when ledger chain verification fails.</p> Source code in <code>src/geas_ai/core/ledger.py</code> <pre><code>class LedgerIntegrityError(Exception):\n    \"\"\"Raised when ledger chain verification fails.\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference/#geas_ai.core.ledger.LedgerManager","title":"<code>LedgerManager</code>","text":"<p>Manages lock.json operations.</p> Source code in <code>src/geas_ai/core/ledger.py</code> <pre><code>class LedgerManager:\n    \"\"\"Manages lock.json operations.\"\"\"\n\n    @staticmethod\n    def load_lock(bolt_path: Path) -&gt; Optional[Ledger]:\n        \"\"\"Loads the ledger from lock.json if it exists.\"\"\"\n        lock_path = bolt_path / LOCK_FILE_NAME\n        if not lock_path.exists():\n            return None\n\n        try:\n            with open(lock_path, \"r\", encoding=\"utf-8\") as f:\n                data = json.load(f)\n                return Ledger(**data)\n        except Exception:\n            # If load fails (e.g. empty or corrupted), we treat as None or raise\n            # For now, let's raise to indicate corruption\n            raise\n\n    @staticmethod\n    def save_lock(bolt_path: Path, ledger: Ledger) -&gt; None:\n        \"\"\"Saves the ledger to lock.json.\"\"\"\n        lock_path = bolt_path / LOCK_FILE_NAME\n        with open(lock_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(ledger.model_dump_json(indent=2))\n\n    @staticmethod\n    def create_genesis_ledger(bolt_id: str) -&gt; Ledger:\n        \"\"\"Creates a new empty ledger.\"\"\"\n        return Ledger(bolt_id=bolt_id, created_at=datetime.utcnow(), events=[])\n\n    @staticmethod\n    def append_event(ledger: Ledger, event_data: LedgerEvent) -&gt; Ledger:\n        \"\"\"\n        Appends a new event to the ledger.\n        Updates sequence, prev_hash, and calculates event_hash.\n        Note: The input event_data should have action, payload, identity set.\n        Sequence, timestamp, prev_hash, event_hash will be handled here if not set correctly,\n        but for strictness we expect caller to prepare most of it,\n        EXCEPT hashing and linking which MUST be done here to ensure consistency.\n\n        However, to simplify usage: we will take a partially constructed event\n        or arguments and build the final event here.\n\n        Let's assume the caller constructs a LedgerEvent BUT we override\n        sequence, prev_hash, and event_hash to ensure integrity.\n        \"\"\"\n\n        # 1. Determine Sequence\n        new_sequence = len(ledger.events) + 1\n\n        # 2. Get Prev Hash\n        prev_hash = ledger.head_hash\n\n        # 3. Update Event fields\n        event_data.sequence = new_sequence\n        event_data.prev_hash = prev_hash\n\n        # 4. Calculate Event Hash\n        # Convert to dict, exclude 'event_hash' for calculation\n        event_dict = event_data.model_dump(mode=\"json\")\n        if \"event_hash\" in event_dict:\n            del event_dict[\"event_hash\"]\n\n        event_hash = calculate_event_hash(event_dict)\n        event_data.event_hash = event_hash\n\n        # 5. Append and Update Head\n        ledger.events.append(event_data)\n        ledger.head_hash = event_hash\n\n        return ledger\n\n    @staticmethod\n    def verify_chain_integrity(ledger: Ledger) -&gt; bool:\n        \"\"\"\n        Verifies the hash chain integrity of the ledger.\n        \"\"\"\n        current_prev_hash = None\n\n        for i, event in enumerate(ledger.events):\n            # Check sequence\n            if event.sequence != i + 1:\n                return False\n\n            # Check prev_hash linking\n            if event.prev_hash != current_prev_hash:\n                return False\n\n            # Check event hash\n            event_dict = event.model_dump(mode=\"json\")\n            if \"event_hash\" in event_dict:\n                del event_dict[\"event_hash\"]\n\n            calculated_hash = calculate_event_hash(event_dict)\n            if calculated_hash != event.event_hash:\n                return False\n\n            current_prev_hash = event.event_hash\n\n        # Check head hash matches last event\n        if ledger.events and ledger.head_hash != ledger.events[-1].event_hash:\n            return False\n\n        return True\n</code></pre>"},{"location":"reference/#geas_ai.core.ledger.LedgerManager.append_event","title":"<code>append_event(ledger, event_data)</code>  <code>staticmethod</code>","text":"<p>Appends a new event to the ledger. Updates sequence, prev_hash, and calculates event_hash. Note: The input event_data should have action, payload, identity set. Sequence, timestamp, prev_hash, event_hash will be handled here if not set correctly, but for strictness we expect caller to prepare most of it, EXCEPT hashing and linking which MUST be done here to ensure consistency.</p> <p>However, to simplify usage: we will take a partially constructed event or arguments and build the final event here.</p> <p>Let's assume the caller constructs a LedgerEvent BUT we override sequence, prev_hash, and event_hash to ensure integrity.</p> Source code in <code>src/geas_ai/core/ledger.py</code> <pre><code>@staticmethod\ndef append_event(ledger: Ledger, event_data: LedgerEvent) -&gt; Ledger:\n    \"\"\"\n    Appends a new event to the ledger.\n    Updates sequence, prev_hash, and calculates event_hash.\n    Note: The input event_data should have action, payload, identity set.\n    Sequence, timestamp, prev_hash, event_hash will be handled here if not set correctly,\n    but for strictness we expect caller to prepare most of it,\n    EXCEPT hashing and linking which MUST be done here to ensure consistency.\n\n    However, to simplify usage: we will take a partially constructed event\n    or arguments and build the final event here.\n\n    Let's assume the caller constructs a LedgerEvent BUT we override\n    sequence, prev_hash, and event_hash to ensure integrity.\n    \"\"\"\n\n    # 1. Determine Sequence\n    new_sequence = len(ledger.events) + 1\n\n    # 2. Get Prev Hash\n    prev_hash = ledger.head_hash\n\n    # 3. Update Event fields\n    event_data.sequence = new_sequence\n    event_data.prev_hash = prev_hash\n\n    # 4. Calculate Event Hash\n    # Convert to dict, exclude 'event_hash' for calculation\n    event_dict = event_data.model_dump(mode=\"json\")\n    if \"event_hash\" in event_dict:\n        del event_dict[\"event_hash\"]\n\n    event_hash = calculate_event_hash(event_dict)\n    event_data.event_hash = event_hash\n\n    # 5. Append and Update Head\n    ledger.events.append(event_data)\n    ledger.head_hash = event_hash\n\n    return ledger\n</code></pre>"},{"location":"reference/#geas_ai.core.ledger.LedgerManager.create_genesis_ledger","title":"<code>create_genesis_ledger(bolt_id)</code>  <code>staticmethod</code>","text":"<p>Creates a new empty ledger.</p> Source code in <code>src/geas_ai/core/ledger.py</code> <pre><code>@staticmethod\ndef create_genesis_ledger(bolt_id: str) -&gt; Ledger:\n    \"\"\"Creates a new empty ledger.\"\"\"\n    return Ledger(bolt_id=bolt_id, created_at=datetime.utcnow(), events=[])\n</code></pre>"},{"location":"reference/#geas_ai.core.ledger.LedgerManager.load_lock","title":"<code>load_lock(bolt_path)</code>  <code>staticmethod</code>","text":"<p>Loads the ledger from lock.json if it exists.</p> Source code in <code>src/geas_ai/core/ledger.py</code> <pre><code>@staticmethod\ndef load_lock(bolt_path: Path) -&gt; Optional[Ledger]:\n    \"\"\"Loads the ledger from lock.json if it exists.\"\"\"\n    lock_path = bolt_path / LOCK_FILE_NAME\n    if not lock_path.exists():\n        return None\n\n    try:\n        with open(lock_path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n            return Ledger(**data)\n    except Exception:\n        # If load fails (e.g. empty or corrupted), we treat as None or raise\n        # For now, let's raise to indicate corruption\n        raise\n</code></pre>"},{"location":"reference/#geas_ai.core.ledger.LedgerManager.save_lock","title":"<code>save_lock(bolt_path, ledger)</code>  <code>staticmethod</code>","text":"<p>Saves the ledger to lock.json.</p> Source code in <code>src/geas_ai/core/ledger.py</code> <pre><code>@staticmethod\ndef save_lock(bolt_path: Path, ledger: Ledger) -&gt; None:\n    \"\"\"Saves the ledger to lock.json.\"\"\"\n    lock_path = bolt_path / LOCK_FILE_NAME\n    with open(lock_path, \"w\", encoding=\"utf-8\") as f:\n        f.write(ledger.model_dump_json(indent=2))\n</code></pre>"},{"location":"reference/#geas_ai.core.ledger.LedgerManager.verify_chain_integrity","title":"<code>verify_chain_integrity(ledger)</code>  <code>staticmethod</code>","text":"<p>Verifies the hash chain integrity of the ledger.</p> Source code in <code>src/geas_ai/core/ledger.py</code> <pre><code>@staticmethod\ndef verify_chain_integrity(ledger: Ledger) -&gt; bool:\n    \"\"\"\n    Verifies the hash chain integrity of the ledger.\n    \"\"\"\n    current_prev_hash = None\n\n    for i, event in enumerate(ledger.events):\n        # Check sequence\n        if event.sequence != i + 1:\n            return False\n\n        # Check prev_hash linking\n        if event.prev_hash != current_prev_hash:\n            return False\n\n        # Check event hash\n        event_dict = event.model_dump(mode=\"json\")\n        if \"event_hash\" in event_dict:\n            del event_dict[\"event_hash\"]\n\n        calculated_hash = calculate_event_hash(event_dict)\n        if calculated_hash != event.event_hash:\n            return False\n\n        current_prev_hash = event.event_hash\n\n    # Check head hash matches last event\n    if ledger.events and ledger.head_hash != ledger.events[-1].event_hash:\n        return False\n\n    return True\n</code></pre>"},{"location":"reference/#geas_ai.core.workflow","title":"<code>geas_ai.core.workflow</code>","text":""},{"location":"reference/#geas_ai.core.workflow.WorkflowManager","title":"<code>WorkflowManager</code>","text":"<p>Manages workflow configuration loading and validation.</p> Source code in <code>src/geas_ai/core/workflow.py</code> <pre><code>class WorkflowManager:\n    \"\"\"Manages workflow configuration loading and validation.\"\"\"\n\n    DEFAULT_WORKFLOW = WorkflowConfig(\n        name=\"standard_dev\",\n        version=\"1.0\",\n        intent_documents=IntentConfig(\n            required=[\"01_request.md\", \"02_specs.md\"], optional=[\"03_plan.md\"]\n        ),\n        stages=[\n            WorkflowStage(\n                id=\"req\",\n                action=\"SEAL_REQ\",\n                required_role=\"human\",\n                description=\"Seal Requirements\",\n            ),\n            WorkflowStage(\n                id=\"specs\",\n                action=\"SEAL_SPECS\",\n                required_role=\"human\",\n                prerequisite=\"req\",\n                description=\"Seal Specifications\",\n            ),\n            WorkflowStage(\n                id=\"plan\",\n                action=\"SEAL_PLAN\",\n                required_role=\"agent\",\n                prerequisite=\"specs\",\n                description=\"Seal Implementation Plan\",\n            ),\n            WorkflowStage(\n                id=\"intent\",\n                action=\"SEAL_INTENT\",\n                required_role=\"human\",\n                prerequisite=\"plan\",\n                description=\"Seal Intent (Req + Specs + Plan)\",\n            ),\n            WorkflowStage(\n                id=\"mrp\",\n                action=\"SEAL_MRP\",\n                required_role=\"agent\",\n                prerequisite=\"intent\",\n                description=\"Seal Merge Request Package\",\n            ),\n            WorkflowStage(\n                id=\"approve\",\n                action=\"APPROVE\",\n                required_role=\"human\",\n                prerequisite=\"mrp\",\n                description=\"Approve for Merge\",\n            ),\n        ],\n    )\n\n    @staticmethod\n    def load_workflow(config_path: Optional[Path] = None) -&gt; WorkflowConfig:\n        \"\"\"\n        Loads the workflow configuration.\n        Returns hardcoded default if file is missing.\n        \"\"\"\n        if config_path and config_path.exists():\n            yaml = YAML()\n            try:\n                with open(config_path, \"r\") as f:\n                    data = yaml.load(f)\n                    return WorkflowConfig(**data)\n            except Exception:\n                # Log warning? For now fallback.\n                pass\n\n        return WorkflowManager.DEFAULT_WORKFLOW\n</code></pre>"},{"location":"reference/#geas_ai.core.workflow.WorkflowManager.load_workflow","title":"<code>load_workflow(config_path=None)</code>  <code>staticmethod</code>","text":"<p>Loads the workflow configuration. Returns hardcoded default if file is missing.</p> Source code in <code>src/geas_ai/core/workflow.py</code> <pre><code>@staticmethod\ndef load_workflow(config_path: Optional[Path] = None) -&gt; WorkflowConfig:\n    \"\"\"\n    Loads the workflow configuration.\n    Returns hardcoded default if file is missing.\n    \"\"\"\n    if config_path and config_path.exists():\n        yaml = YAML()\n        try:\n            with open(config_path, \"r\") as f:\n                data = yaml.load(f)\n                return WorkflowConfig(**data)\n        except Exception:\n            # Log warning? For now fallback.\n            pass\n\n    return WorkflowManager.DEFAULT_WORKFLOW\n</code></pre>"},{"location":"reference/#geas_ai.core.hashing","title":"<code>geas_ai.core.hashing</code>","text":""},{"location":"reference/#geas_ai.core.hashing.calculate_event_hash","title":"<code>calculate_event_hash(event_data)</code>","text":"<p>Calculates the SHA-256 hash of a ledger event.</p> <p>The event dictionary should exclude the 'event_hash' field itself before calling this function if it was already present.</p> Source code in <code>src/geas_ai/core/hashing.py</code> <pre><code>def calculate_event_hash(event_data: Dict[str, Any]) -&gt; str:\n    \"\"\"\n    Calculates the SHA-256 hash of a ledger event.\n\n    The event dictionary should exclude the 'event_hash' field itself\n    before calling this function if it was already present.\n    \"\"\"\n    canonical_bytes = canonicalize_json(event_data)\n    sha256_hash = hashlib.sha256(canonical_bytes).hexdigest()\n    return f\"sha256:{sha256_hash}\"\n</code></pre>"},{"location":"reference/#geas_ai.core.hashing.file_sha256","title":"<code>file_sha256(file_path)</code>","text":"<p>Computes SHA256 hash of the file content (normalized to UTF-8 text if possible).</p> Source code in <code>src/geas_ai/core/hashing.py</code> <pre><code>def file_sha256(file_path: Path) -&gt; str:\n    \"\"\"Computes SHA256 hash of the file content (normalized to UTF-8 text if possible).\"\"\"\n    sha256 = hashlib.sha256()\n    with open(file_path, \"rb\") as f:\n        # Read in chunks to be memory efficient\n        for chunk in iter(lambda: f.read(4096), b\"\"):\n            sha256.update(chunk)\n    return f\"sha256:{sha256.hexdigest()}\"\n</code></pre>"},{"location":"reference/#geas_ai.core.manifest","title":"<code>geas_ai.core.manifest</code>","text":""},{"location":"reference/#geas_ai.core.manifest.calculate_merkle_root","title":"<code>calculate_merkle_root(files)</code>","text":"<p>Calculates the Merkle Root from a dictionary of file paths and their SHA256 hashes.</p> <p>Logic: 1. Leaves: Sort filepaths -&gt; Extract hashes. 2. Leaf Hashing: We use the hash provided in the dict (SHA256 of content). 3. Tree Construction:     - Pair adjacent nodes (A, B).     - Parent = SHA256(A + B).     - If odd count, Parent = SHA256(Last + Last).     - Repeat until Root.</p> Source code in <code>src/geas_ai/core/manifest.py</code> <pre><code>def calculate_merkle_root(files: Dict[str, str]) -&gt; str:\n    \"\"\"\n    Calculates the Merkle Root from a dictionary of file paths and their SHA256 hashes.\n\n    Logic:\n    1. Leaves: Sort filepaths -&gt; Extract hashes.\n    2. Leaf Hashing: We use the hash provided in the dict (SHA256 of content).\n    3. Tree Construction:\n        - Pair adjacent nodes (A, B).\n        - Parent = SHA256(A + B).\n        - If odd count, Parent = SHA256(Last + Last).\n        - Repeat until Root.\n    \"\"\"\n    if not files:\n        # Return hash of empty string if no files\n        return hashlib.sha256(b\"\").hexdigest()\n\n    # Sort by filepath to ensure deterministic ordering\n    sorted_paths = sorted(files.keys())\n    # Extract hashes\n    leaves = [files[path] for path in sorted_paths]\n\n    current_level = leaves\n\n    while len(current_level) &gt; 1:\n        next_level = []\n        for i in range(0, len(current_level), 2):\n            left = current_level[i]\n            if i + 1 &lt; len(current_level):\n                right = current_level[i + 1]\n            else:\n                # Odd count, duplicate last\n                right = left\n\n            # Combine hashes and hash again\n            combined = (left + right).encode(\"utf-8\")\n            parent_hash = hashlib.sha256(combined).hexdigest()\n            next_level.append(parent_hash)\n        current_level = next_level\n\n    return current_level[0]\n</code></pre>"},{"location":"reference/#geas_ai.core.manifest.generate_manifest","title":"<code>generate_manifest(bolt_id, scope, files, test_result)</code>","text":"<p>Generates the Manifest object.</p> Source code in <code>src/geas_ai/core/manifest.py</code> <pre><code>def generate_manifest(\n    bolt_id: str, scope: List[str], files: Dict[str, str], test_result: TestResultInfo\n) -&gt; Manifest:\n    \"\"\"Generates the Manifest object.\"\"\"\n    root_hash = calculate_merkle_root(files)\n\n    return Manifest(\n        bolt_id=bolt_id,\n        generated_at=datetime.now(timezone.utc),\n        scope=scope,\n        files=files,\n        root_hash=root_hash,\n        test_result=test_result,\n    )\n</code></pre>"},{"location":"reference/#geas_ai.core.walker","title":"<code>geas_ai.core.walker</code>","text":""},{"location":"reference/#geas_ai.core.walker.load_gitignore_patterns","title":"<code>load_gitignore_patterns(root_dir)</code>","text":"<p>Loads .gitignore patterns from the root directory if it exists. Always includes default ignore patterns for .geas, pycache, and .git.</p> Source code in <code>src/geas_ai/core/walker.py</code> <pre><code>def load_gitignore_patterns(root_dir: Path) -&gt; pathspec.PathSpec:\n    \"\"\"\n    Loads .gitignore patterns from the root directory if it exists.\n    Always includes default ignore patterns for .geas, __pycache__, and .git.\n    \"\"\"\n    gitignore_path = root_dir / \".gitignore\"\n    patterns = []\n\n    # Always ignore these\n    default_ignores = [\".geas/\", \"__pycache__/\", \".git/\", \"*.pyc\"]\n    patterns.extend(default_ignores)\n\n    if gitignore_path.exists():\n        with open(gitignore_path, \"r\") as f:\n            patterns.extend(f.readlines())\n\n    return pathspec.PathSpec.from_lines(\"gitwildmatch\", patterns)\n</code></pre>"},{"location":"reference/#geas_ai.core.walker.walk_source_files","title":"<code>walk_source_files(root_dir, scope_dirs)</code>","text":"<p>Recursively walks the specified scope directories, filtering files based on .gitignore and default ignore patterns.</p> <p>Parameters:</p> Name Type Description Default <code>root_dir</code> <code>Path</code> <p>The root directory of the project.</p> required <code>scope_dirs</code> <code>List[str]</code> <p>List of directory names (relative to root) to include in the walk.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of file paths relative to root_dir.</p> Source code in <code>src/geas_ai/core/walker.py</code> <pre><code>def walk_source_files(root_dir: Path, scope_dirs: List[str]) -&gt; List[str]:\n    \"\"\"\n    Recursively walks the specified scope directories, filtering files based on .gitignore\n    and default ignore patterns.\n\n    Args:\n        root_dir: The root directory of the project.\n        scope_dirs: List of directory names (relative to root) to include in the walk.\n\n    Returns:\n        List of file paths relative to root_dir.\n    \"\"\"\n    spec = load_gitignore_patterns(root_dir)\n    collected_files = []\n\n    # Ensure scope directories exist\n    valid_scope_dirs = []\n    for d in scope_dirs:\n        p = root_dir / d\n        if p.exists() and p.is_dir():\n            valid_scope_dirs.append(d)\n        # We silently skip missing directories as per previous discussion (\"just raise a warning\" handled by caller or implied here)\n        # Actually, the user said \"just raise a warning\" for missing scope.\n        # I will let the caller handle warnings if needed, here I just walk what exists.\n\n    for scope_dir in valid_scope_dirs:\n        # Walk logic\n        base_path = root_dir / scope_dir\n\n        # We walk everything under the scope_dir\n        for root, dirs, files in os.walk(base_path):\n            # Calculate relative path from project root for filtering\n            rel_root = Path(root).relative_to(root_dir)\n\n            # Filter directories to prevent traversing into ignored ones\n            # pathspec.match_file returns True if it matches an ignore pattern\n            # We need to modify 'dirs' in-place to prune the walk\n\n            # Filter dirs\n            # We must check each dir against the spec.\n            # The spec expects paths relative to the root of the gitignore context (project root)\n            dirs[:] = [\n                d\n                for d in dirs\n                if not spec.match_file(str(rel_root / d) + \"/\")\n                # appending \"/\" helps pathspec identify it as directory if the pattern ends with /\n            ]\n\n            for file in files:\n                file_rel_path = rel_root / file\n                if not spec.match_file(str(file_rel_path)):\n                    collected_files.append(str(file_rel_path))\n\n    return sorted(collected_files)\n</code></pre>"},{"location":"reference/#geas_ai.core.testing","title":"<code>geas_ai.core.testing</code>","text":""},{"location":"reference/#geas_ai.core.testing.run_tests","title":"<code>run_tests(command='uv run pytest', timeout=300)</code>","text":"<p>Executes the test command and captures the result.</p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str</code> <p>The shell command to run tests.</p> <code>'uv run pytest'</code> <code>timeout</code> <code>int</code> <p>Maximum execution time in seconds.</p> <code>300</code> <p>Returns:</p> Type Description <code>TestResultInfo</code> <p>TestResultInfo object containing execution details.</p> Source code in <code>src/geas_ai/core/testing.py</code> <pre><code>def run_tests(command: str = \"uv run pytest\", timeout: int = 300) -&gt; TestResultInfo:\n    \"\"\"\n    Executes the test command and captures the result.\n\n    Args:\n        command: The shell command to run tests.\n        timeout: Maximum execution time in seconds.\n\n    Returns:\n        TestResultInfo object containing execution details.\n    \"\"\"\n    start_time = time.time()\n\n    try:\n        # Run the command\n        # using shlex.split to properly parse command arguments\n        # capture_output=True captures stdout and stderr\n        # text=True decodes output as string\n        result = subprocess.run(\n            shlex.split(command), timeout=timeout, capture_output=True, text=True\n        )\n\n        duration = time.time() - start_time\n        passed = result.returncode == 0\n\n        return TestResultInfo(\n            passed=passed,\n            exit_code=result.returncode,\n            duration_seconds=duration,\n            timestamp=datetime.now(timezone.utc),\n            output=result.stdout + \"\\n\" + result.stderr,\n        )\n\n    except subprocess.TimeoutExpired as e:\n        duration = time.time() - start_time\n        output = e.stdout.decode() if e.stdout else \"\"\n        output += \"\\n\" + (e.stderr.decode() if e.stderr else \"\")\n        output += f\"\\nTimeout expired after {timeout} seconds.\"\n        return TestResultInfo(\n            passed=False,\n            exit_code=124,  # Standard timeout exit code\n            duration_seconds=duration,\n            timestamp=datetime.now(timezone.utc),\n            output=output,\n        )\n    except Exception as e:\n        # Fallback for other errors (e.g. command not found)\n        duration = time.time() - start_time\n        return TestResultInfo(\n            passed=False,\n            exit_code=1,\n            duration_seconds=duration,\n            timestamp=datetime.now(timezone.utc),\n            output=str(e),\n        )\n</code></pre>"},{"location":"reference/#schemas","title":"Schemas","text":""},{"location":"reference/#geas_ai.schemas.identity","title":"<code>geas_ai.schemas.identity</code>","text":""},{"location":"reference/#geas_ai.schemas.ledger","title":"<code>geas_ai.schemas.ledger</code>","text":""},{"location":"reference/#geas_ai.schemas.workflow","title":"<code>geas_ai.schemas.workflow</code>","text":""}]}